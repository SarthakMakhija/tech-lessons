<!DOCTYPE html> <!-- Type on Strap jekyll theme v2.0.0 Copyright 2016-2019 Sylhare Theme free for personal and commercial use under the MIT license https://github.com/sylhare/Type-on-Strap/blob/master/LICENSE --> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"> <!-- CSS --> <link rel="stylesheet" href="/assets/css/main.css"> <!--Favicon--> <link rel="shortcut icon" href="/assets/favicon.png" type="image/x-icon"> <!-- Canonical --> <link rel="canonical" href="https://tech-lessons.in/count-min-sketch/"> <!-- KaTeX 0.8.3 --> <!-- if you have any issue check https://github.com/KaTeX/KaTeX --> <!-- Google Analytics --> <!-- End Google Analytics --> <!-- seo tags --> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Count-min sketch | tech-lessons.in</title> <meta name="generator" content="Jekyll v4.3.2" /> <meta property="og:title" content="Count-min sketch" /> <meta name="author" content="Sarthak Makhija" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="Count-min sketch (CM sketch) is a probabilistic data structure used to estimate the frequency of events in a data stream. The count–min sketch was invented in 2003 by Graham Cormode and S. Muthu Muthukrishnan." /> <meta property="og:description" content="Count-min sketch (CM sketch) is a probabilistic data structure used to estimate the frequency of events in a data stream. The count–min sketch was invented in 2003 by Graham Cormode and S. Muthu Muthukrishnan." /> <link rel="canonical" href="https://tech-lessons.in/count-min-sketch/" /> <meta property="og:url" content="https://tech-lessons.in/count-min-sketch/" /> <meta property="og:site_name" content="tech-lessons.in" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2023-02-24T00:00:00+05:30" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Count-min sketch" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Sarthak Makhija","url":"https://github.com/sarthakmakhija"},"dateModified":"2023-02-24T00:00:00+05:30","datePublished":"2023-02-24T00:00:00+05:30","description":"Count-min sketch (CM sketch) is a probabilistic data structure used to estimate the frequency of events in a data stream. The count–min sketch was invented in 2003 by Graham Cormode and S. Muthu Muthukrishnan.","headline":"Count-min sketch","mainEntityOfPage":{"@type":"WebPage","@id":"https://tech-lessons.in/count-min-sketch/"},"url":"https://tech-lessons.in/count-min-sketch/"}</script> <!-- End Jekyll SEO tag --> <!-- Manual seo tags --> <!-- <title>Count-min sketch | tech-lessons.in</title> <meta name="description" content="Count-min sketch (CM sketch) is a probabilistic data structure used to estimate the frequency of events in a data stream. The count–min sketch was invented i..."> --> </head> <script defer=true src="/assets/js/main.min.js"></script> <body> <header class="site-header"> <!-- Toggle menu --> <nav class="clear"> <a aria-label="pull" id="pull" class="toggle" href="#"> <i class="fa fa-bars fa-lg"></i> </a> <!-- Brand Logo --> <a class="navbar-brand" href="/"> <img src="/assets/img/pexels/logo.png" alt="tech-lessons" title="tech-lessons"> </a> <!-- Menu --> <ul class="hide"> <li class="separator"> |</li> <li> <a class="clear" aria-label="Home" title="Home" href="/"> <i class="fa fa-fw fa-home" aria-hidden="true"></i> Home </a> </li> <li class="separator"> |</li> <li> <a class="clear" aria-label="Search" title="Search" href="/search/"> <i class="fa fa-fw fa-search" aria-hidden="true"></i> Search </a> </li> <li class="separator"> |</li> <li> <a class="clear" aria-label="Tags" title="Tags" href="/tags/"> <i class="fa fa-fw fa-tags" aria-hidden="true"></i> Tags </a> </li> <li class="separator"> |</li> <li> <a class="clear" aria-label="About Me" title="About Me" href="/about/"> <i class="fa fa-fw fa-male" aria-hidden="true"></i> About Me </a> </li> </ul> </nav> </header> <div class="content"> <meta property="og:url" content="/count-min-sketch/" /> <meta property="og:type" content="article" /> <meta property="og:title" content="Count-min sketch" /> <meta property="og:description" content="Count-min sketch (CM sketch) is a probabilistic data structure used to estimate the frequency of events in a data stream. The count–min sketch was invented in 2003 by Graham Cormode and S. Muthu Muthukrishnan." /> <meta property="og:image" content="assets/img/pexels/countminsketch-title.png" /> <article class="feature-image"> <header id="main" style=""></header> <section class="post-content"> <h1 id="Count-min+sketch" class="title">Count-min sketch</h1> <p>Count-min sketch (CM sketch) is a probabilistic data structure<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> used to estimate the frequency of events in a data stream.</p> <p>It relies on hash functions to map events to frequencies, but unlike a hash table, it uses only sublinear space at the expense of over-counting some events due to hash collisions. The count–min sketch was invented in 2003 by Graham Cormode and S. Muthu Muthukrishnan.</p> <h3 id="understanding-count-min-sketch">Understanding Count-min Sketch</h3> <p>Let’s say we want to build a solution to count the frequency of elements in a data stream. One idea would be to use a <code class="language-plaintext highlighter-rouge">hashmap</code> with the data element as the key and count as the value. The approach works but does not scale with a data stream comprising billions of elements, the most unique.</p> <p>We will have two challenges with <code class="language-plaintext highlighter-rouge">hashmap</code> in this case:</p> <ol> <li>The number of elements in the hashmap will tend towards a billion. The overall space complexity would be O(N)<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup></li> <li>Rehashing can place significant CPU pressure</li> </ol> <p>This is where the Count-min sketch comes into the picture. The count-min sketch is a probabilistic data structure that can <strong>estimate</strong> the frequency of elements by using sublinear space at the expense of over-counting some elements due to hash collisions.</p> <div class="align-center"> <img style="padding-left: 0; max-width: 90%" src="/assets/img/pexels/countminsketch.png" class="wp-image-878" /> </div> <p>Count-min sketch is represented as a D*W matrix, where D is the total number of hash functions (or depth) and W is the width or the number of counters per hash function. The matrix is initialized with zero at the beginning. A count-min sketch can be represented with the following structure:</p> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">depth</span> <span class="o">=</span> <span class="m">4</span>

<span class="k">type</span> <span class="n">CountMinSketch</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">matrix</span>        <span class="p">[</span><span class="n">depth</span><span class="p">]</span><span class="n">row</span>
    <span class="n">seeds</span>         <span class="p">[</span><span class="n">depth</span><span class="p">]</span><span class="kt">uint64</span>
    <span class="n">totalCounters</span> <span class="kt">uint64</span>
<span class="p">}</span>

<span class="k">type</span> <span class="n">row</span> <span class="p">[]</span><span class="kt">byte</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">CountMinSketch</code> contains the following:</p> <ol> <li>A matrix of a byte array to store the counters. Each row will have <code class="language-plaintext highlighter-rouge">W</code> cells, and each cell will contain a byte.</li> <li>The total number of rows (or the total number of hash functions) is limited to four in the above code. So, D here is 4.</li> <li>An array of seed values of type <code class="language-plaintext highlighter-rouge">uint64</code> will be used to generate the hash of the data element.</li> <li>Total number of counters</li> </ol> <blockquote> <p>We plan to use a “four-bit counter” approach, with the lower four bits of a byte to store the counter for a key <em>K1</em> and the upper four bits to hold the counter for another key <em>K2</em>. That means a byte will store the counts for two keys.</p> </blockquote> <p><em>From now on, we will use the term “key” over “data element”</em>. Count-min sketch supports two operations - <code class="language-plaintext highlighter-rouge">increment(key)</code> and <code class="language-plaintext highlighter-rouge">estimate(key)</code>. Let’s understand the working of these operations.</p> <p>The idea behind the <code class="language-plaintext highlighter-rouge">increment</code> operation can be summarized as follows:</p> <ol> <li>Run D hash functions on the given key (hash0, hash1 and hash2 in the image above).</li> <li>Find a column index in the matrix by performing <code class="language-plaintext highlighter-rouge">hashValue % totalCounters</code>.</li> <li>Increment the value at the identified matrix cell using <a href="#4-bit-counter">four-bit counter approach</a>.</li> </ol> <p>The idea behind the <code class="language-plaintext highlighter-rouge">estimate</code> operation is similar to the <code class="language-plaintext highlighter-rouge">increment</code> operation.</p> <ol> <li>Run D hash functions on the given key (hash0, hash1 and hash2 in the above image).</li> <li>Find a column index in the matrix by performing <code class="language-plaintext highlighter-rouge">hashValue % totalCounters</code>.</li> <li>Return the <strong>minimum value</strong> from all the identified matrix cells.</li> </ol> <blockquote> <p>We return the <strong>minimum value</strong> from all the identified matrix cells to account for hash conflicts between keys. 2 keys might get the same column index (<code class="language-plaintext highlighter-rouge">hashValue % totalCounters</code>) for the 0th row, but they might get different column indices for the 1st row. So, we take the minimum counter value from all the identified matrix cells to reduce the impact of hash conflicts between keys.</p> </blockquote> <h3 id="adding-tests-for-increment-and-estimate">Adding tests for increment and estimate</h3> <p>Let’s add a test for <code class="language-plaintext highlighter-rouge">increment</code> and <code class="language-plaintext highlighter-rouge">estimate</code> operations.</p> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">TestGetsTheEstimateForKeysInAStream</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">stream</span> <span class="o">:=</span> <span class="p">[]</span><span class="n">model</span><span class="o">.</span><span class="n">Slice</span><span class="p">{</span>
        <span class="n">model</span><span class="o">.</span><span class="n">NewSlice</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"A"</span><span class="p">)),</span> 
        <span class="n">model</span><span class="o">.</span><span class="n">NewSlice</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"B"</span><span class="p">)),</span>
        <span class="n">model</span><span class="o">.</span><span class="n">NewSlice</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"A"</span><span class="p">)),</span> 
        <span class="n">model</span><span class="o">.</span><span class="n">NewSlice</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"C"</span><span class="p">)),</span>
        <span class="n">model</span><span class="o">.</span><span class="n">NewSlice</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"B"</span><span class="p">)),</span> 
        <span class="n">model</span><span class="o">.</span><span class="n">NewSlice</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"A"</span><span class="p">)),</span>
        <span class="n">model</span><span class="o">.</span><span class="n">NewSlice</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"B"</span><span class="p">)),</span> 
        <span class="n">model</span><span class="o">.</span><span class="n">NewSlice</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"C"</span><span class="p">)),</span>
    <span class="p">}</span>
    <span class="n">expectedCounts</span> <span class="o">:=</span> <span class="k">map</span><span class="p">[</span><span class="kt">string</span><span class="p">]</span><span class="kt">byte</span><span class="p">{</span>
        <span class="s">"A"</span><span class="o">:</span> <span class="m">3</span><span class="p">,</span>
        <span class="s">"B"</span><span class="o">:</span> <span class="m">3</span><span class="p">,</span>
        <span class="s">"C"</span><span class="o">:</span> <span class="m">2</span><span class="p">,</span>
    <span class="p">}</span>

    <span class="c">//instantiate countMinSketch with ten counters</span>
    <span class="n">countMinSketch</span> <span class="o">:=</span> <span class="n">newCountMinSketch</span><span class="p">(</span><span class="m">10</span><span class="p">)</span>

    <span class="c">//increment</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">stream</span> <span class="p">{</span>
        <span class="n">countMinSketch</span><span class="o">.</span><span class="n">Increment</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="p">}</span>

    <span class="c">//estimate the count</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">stream</span> <span class="p">{</span>
        <span class="n">count</span> <span class="o">:=</span> <span class="n">countMinSketch</span><span class="o">.</span><span class="n">Estimate</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
       <span class="k">if</span> <span class="n">count</span> <span class="o">&lt;</span> <span class="n">expectedCounts</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">AsString</span><span class="p">()]</span> <span class="p">{</span>
                <span class="n">t</span><span class="o">.</span><span class="n">Fatalf</span><span class="p">(</span>
                    <span class="s">"Expected at least the count %v for key %v, received %v"</span><span class="p">,</span> 
                    <span class="n">expectedCounts</span><span class="p">[</span><span class="n">key</span><span class="o">.</span><span class="n">AsString</span><span class="p">()],</span> 
                    <span class="n">key</span><span class="o">.</span><span class="n">AsString</span><span class="p">(),</span> 
                    <span class="n">count</span>
                <span class="p">)</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>Let’s quickly understand the test:</p> <ol> <li>Create a <code class="language-plaintext highlighter-rouge">stream</code> of keys. Keys are represented by the <code class="language-plaintext highlighter-rouge">Slice</code> abstraction, which is a wrapper over a byte slice.</li> <li>Create a count-min sketch with ten counters (width as 10) <ul> <li>We will see in the code that the counters are in the power of 2.</li> </ul> </li> <li>Increment the count for all the keys in the stream.</li> <li>Assert the estimate of count for all the keys <blockquote> <p>As a part of the assertion, we want to ensure that the estimated count is “at least” equal to the expected count. In the case of hash collisions between two keys, an estimate of the count might be higher than the expected count. Hence, we hope that the estimated count is “at least” equal to the expected count.</p> </blockquote> </li> </ol> <h3 id="4-bit-counter">4-bit counter</h3> <p>The idea behind the four-bit counter deserves its mention.</p> <ul> <li>We can represent a maximum value of 15 <code class="language-plaintext highlighter-rouge">(00001111)</code> with four bits. This implies that the counter should freeze the moment it reaches 15.</li> <li>We need to use the lower and the upper four bits to represent counters for two different keys.</li> <li>Let’s use the <em>lower four bits to store the counter for even positions of the matrix</em> and <em>higher four bits for odd positions of the matrix</em>.</li> </ul> <div class="align-center"> <img style="padding-left: 0; max-width: 90%" src="/assets/img/pexels/4bitcounter.png" class="wp-image-878" /> </div> <ul> <li>This means if the number is even, we need to increment the lower four bits only if the counter represented by those bits has yet to reach 15.</li> <li>If the number is odd, we need to increment the higher four bits only if the counter represented by those bits has yet to reach 15. To ensure that the counter represented by the higher four bits has not reached 15, we can perform a right shift by four, followed by an AND operation with 0x0f.</li> </ul> <div class="align-center"> <img style="padding-left: 0; max-width: 90%" src="/assets/img/pexels/4bitcounterwithshift.png" class="wp-image-878" /> </div> <ul> <li>Imagine a binary value <code class="language-plaintext highlighter-rouge">11110000</code> at some matrix index. Also, consider that the <code class="language-plaintext highlighter-rouge">Increment</code> operation is called, and the <code class="language-plaintext highlighter-rouge">position</code> is an odd number.</li> <li>We should increment the higher four bits because we have an odd-numbered position. But, the binary value already has the maximum value for an odd number. To ensure that the increment operation does not result in an overflow, we do a right shift by four (<code class="language-plaintext highlighter-rouge">0b11110000 &gt;&gt; 4</code>), which gives us <code class="language-plaintext highlighter-rouge">00001111</code>. Now, we perform an AND operation with <code class="language-plaintext highlighter-rouge">0x0f (00001111)</code> to ensure we only get the lower four bits. We ensure that the value is less than 15 before incrementing. In this case, we do not increment because the counter has reached 15.</li> </ul> <p>Now is the right time to build a count-min sketch.</p> <h3 id="building-count-min-sketch">Building Count-min sketch</h3> <p>Let’s understand the critical aspects of <code class="language-plaintext highlighter-rouge">newCountMinSketch</code> function.</p> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">const</span> <span class="n">depth</span> <span class="o">=</span> <span class="m">4</span>

<span class="k">type</span> <span class="n">row</span> <span class="p">[]</span><span class="kt">byte</span>

<span class="k">type</span> <span class="n">CountMinSketch</span> <span class="k">struct</span> <span class="p">{</span>
   <span class="n">matrix</span>        <span class="p">[</span><span class="n">depth</span><span class="p">]</span><span class="n">row</span>
   <span class="n">seeds</span>         <span class="p">[</span><span class="n">depth</span><span class="p">]</span><span class="kt">uint64</span>
   <span class="n">totalCounters</span> <span class="kt">uint64</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">newCountMinSketch</span><span class="p">(</span><span class="n">counters</span> <span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">CountMinSketch</span> <span class="p">{</span>
    <span class="n">nextPowerOf2</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">counters</span> <span class="kt">int64</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
        <span class="n">counters</span><span class="o">--</span>
        <span class="n">counters</span> <span class="o">|=</span> <span class="n">counters</span> <span class="o">&gt;&gt;</span> <span class="m">1</span>
        <span class="n">counters</span> <span class="o">|=</span> <span class="n">counters</span> <span class="o">&gt;&gt;</span> <span class="m">2</span>
        <span class="n">counters</span> <span class="o">|=</span> <span class="n">counters</span> <span class="o">&gt;&gt;</span> <span class="m">4</span>
        <span class="n">counters</span> <span class="o">|=</span> <span class="n">counters</span> <span class="o">&gt;&gt;</span> <span class="m">8</span>
        <span class="n">counters</span> <span class="o">|=</span> <span class="n">counters</span> <span class="o">&gt;&gt;</span> <span class="m">16</span>
        <span class="n">counters</span> <span class="o">|=</span> <span class="n">counters</span> <span class="o">&gt;&gt;</span> <span class="m">32</span>
        <span class="n">counters</span><span class="o">++</span>
        <span class="k">return</span> <span class="n">counters</span>
    <span class="p">}</span>

    <span class="c">//initialize the source to generate seed values and set the total counters to be a power of 2</span>
    <span class="c">//if the user-specified counter is 10, we get a total of 16 counters</span>
    <span class="n">source</span><span class="p">,</span> <span class="n">updatedCounters</span> <span class="o">:=</span> <span class="n">rand</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="n">rand</span><span class="o">.</span><span class="n">NewSource</span><span class="p">(</span><span class="n">time</span><span class="o">.</span><span class="n">Now</span><span class="p">()</span><span class="o">.</span><span class="n">UnixNano</span><span class="p">())),</span> <span class="n">nextPowerOf2</span><span class="p">(</span><span class="kt">int64</span><span class="p">(</span><span class="n">counters</span><span class="p">))</span>

    <span class="c">//instantiate CountMinSketch</span>
    <span class="n">countMinSketch</span>  <span class="o">:=</span> <span class="o">&amp;</span><span class="n">CountMinSketch</span><span class="p">{</span><span class="n">totalCounters</span><span class="o">:</span> <span class="kt">uint64</span><span class="p">(</span><span class="n">updatedCounters</span><span class="p">)}</span>

    <span class="k">for</span> <span class="n">index</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">depth</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span> <span class="p">{</span>
        <span class="c">//generate a new seed</span>
        <span class="n">countMinSketch</span><span class="o">.</span><span class="n">seeds</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">source</span><span class="o">.</span><span class="n">Uint64</span><span class="p">()</span>
        <span class="c">//create a new byte array using the make function and set the newly created byte array at the current index of the matrix</span>
        <span class="n">countMinSketch</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="nb">make</span><span class="p">(</span><span class="n">row</span><span class="p">,</span> <span class="n">updatedCounters</span><span class="o">/</span><span class="m">2</span><span class="p">)</span> 
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">countMinSketch</span>
<span class="p">}</span>
</code></pre></div></div> <p>The idea behind <code class="language-plaintext highlighter-rouge">newCountMinSketch</code> can be summarized as follows:</p> <ol> <li>Create a new source for generating seed values and set the counter as a power of 2.</li> <li>Set <code class="language-plaintext highlighter-rouge">totalCounters</code> inside <code class="language-plaintext highlighter-rouge">CountMinSketch</code></li> <li>Iterate from index = 0 to depth-1 and do the following: <ul> <li>Generate a new seed value of type <code class="language-plaintext highlighter-rouge">uint64</code></li> <li>Create a new byte array of size <code class="language-plaintext highlighter-rouge">updatedCounters/2</code> using the <code class="language-plaintext highlighter-rouge">make</code> function</li> <li>Set the newly created byte array in the matrix at <code class="language-plaintext highlighter-rouge">index</code></li> </ul> </li> </ol> <blockquote> <p>Every row in the matrix has a byte array of size <code class="language-plaintext highlighter-rouge">updatedCounters/2</code>. Using the four-bit counter approach, each byte stores the counters for two keys. This means that we can reduce the total number of counters by 2. With the input counter as 18, we get the value of <code class="language-plaintext highlighter-rouge">updatedCounters</code> as 32. Using the four-bit counter approach, we end up with 16 cells (32/2) for each row, with each cell containing a byte.</p> </blockquote> <p>The idea behind <code class="language-plaintext highlighter-rouge">Increment</code> can be summarized as follows:</p> <ol> <li>Iterate from index = 0 to depth-1 and do the following: <ul> <li>Run the hash function for the given key and get the hashed value.</li> <li>Identify the <code class="language-plaintext highlighter-rouge">columnIndex</code> using the hashed value by executing <code class="language-plaintext highlighter-rouge">hashedValue % totalCounters</code>.</li> <li>Increment the value in the matrix cell at the position identified by a pair of <code class="language-plaintext highlighter-rouge">(index, columnIndex)</code>. <blockquote> <p>Increment operation will increment either the upper or lower four bits of the byte depending on the matrix cell position.</p> </blockquote> </li> </ul> </li> </ol> <p>This is how the above approach can be implemented in golang:</p> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">countMinSketch</span> <span class="o">*</span><span class="n">CountMinSketch</span><span class="p">)</span> <span class="n">Increment</span><span class="p">(</span><span class="n">key</span> <span class="n">model</span><span class="o">.</span><span class="n">Slice</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">index</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">depth</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span> <span class="p">{</span>
        <span class="c">//compute the hash value</span>
        <span class="n">hash</span>        <span class="o">:=</span> <span class="n">countMinSketch</span><span class="o">.</span><span class="n">runHash</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kt">uint32</span><span class="p">(</span><span class="n">countMinSketch</span><span class="o">.</span><span class="n">seeds</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span>
        <span class="c">//get the current row (instance of type row is an alias for []byte)</span>
        <span class="n">currentRow</span>  <span class="o">:=</span> <span class="n">countMinSketch</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="c">//increment the value from the current row at an index=hash % countMinSketch.totalCounters</span>
        <span class="n">currentRow</span><span class="o">.</span><span class="n">incrementAt</span><span class="p">(</span><span class="n">hash</span> <span class="o">%</span> <span class="n">countMinSketch</span><span class="o">.</span><span class="n">totalCounters</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">currentRow</span> <span class="n">row</span><span class="p">)</span> <span class="n">incrementAt</span><span class="p">(</span><span class="n">position</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">//get the index</span>
    <span class="n">index</span> <span class="o">:=</span> <span class="n">position</span> <span class="o">/</span> <span class="m">2</span>
    <span class="c">//if the position is an odd number, upper four bits store the counter value,</span>
    <span class="c">//else lower four bits store the counter value</span>
    <span class="n">shift</span> <span class="o">:=</span> <span class="p">(</span><span class="n">position</span> <span class="o">&amp;</span> <span class="m">0x01</span><span class="p">)</span> <span class="o">*</span> <span class="m">4</span>    
    <span class="n">isLessThan15</span> <span class="o">:=</span> <span class="p">(</span><span class="n">currentRow</span><span class="p">[</span><span class="n">index</span><span class="p">]</span><span class="o">&gt;&gt;</span><span class="n">shift</span><span class="p">)</span><span class="o">&amp;</span><span class="m">0x0f</span> <span class="o">&lt;</span> <span class="m">0x0f</span>
    <span class="c">//if the value is less than 15, increment</span>
    <span class="k">if</span> <span class="n">isLessThan15</span> <span class="p">{</span>
       <span class="n">currentRow</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">currentRow</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">+</span> <span class="p">(</span><span class="m">1</span> <span class="o">&lt;&lt;</span> <span class="n">shift</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The idea behind <code class="language-plaintext highlighter-rouge">Estimate</code> can be summarized as follows:</p> <ol> <li>Iterate from index = 0 to depth-1 and do the following: <ul> <li>Run the hash function for the given key and get the hashed value.</li> <li>Identify the <code class="language-plaintext highlighter-rouge">columnIndex</code> based on the hashed value by executing <code class="language-plaintext highlighter-rouge">hashedValue % totalCounters</code>.</li> <li>Identify the minimum value from all the eligible cells.</li> </ul> </li> </ol> <p>This is how the above approach can be implemented in golang:</p> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">countMinSketch</span> <span class="o">*</span><span class="n">CountMinSketch</span><span class="p">)</span> <span class="n">Estimate</span><span class="p">(</span><span class="n">key</span> <span class="n">model</span><span class="o">.</span><span class="n">Slice</span><span class="p">)</span> <span class="kt">byte</span> <span class="p">{</span>
   <span class="n">min</span> <span class="o">:=</span> <span class="kt">byte</span><span class="p">(</span><span class="m">255</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">depth</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span> <span class="p">{</span>
        <span class="c">//compute the hash value</span>
        <span class="n">hash</span>       <span class="o">:=</span> <span class="n">countMinSketch</span><span class="o">.</span><span class="n">runHash</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="kt">uint32</span><span class="p">(</span><span class="n">countMinSketch</span><span class="o">.</span><span class="n">seeds</span><span class="p">[</span><span class="n">index</span><span class="p">]))</span>
        <span class="c">//get the current row (an instance of type row is an alias for []byte)</span>
        <span class="n">currentRow</span> <span class="o">:=</span> <span class="n">countMinSketch</span><span class="o">.</span><span class="n">matrix</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="c">//get the value from the current row at an index=hash % countMinSketch.totalCounters and find the minimum value </span>
        <span class="k">if</span> <span class="n">valueAt</span> <span class="o">:=</span> <span class="n">currentRow</span><span class="o">.</span><span class="n">getAt</span><span class="p">(</span><span class="n">hash</span> <span class="o">%</span> <span class="n">countMinSketch</span><span class="o">.</span><span class="n">totalCounters</span><span class="p">);</span> <span class="n">valueAt</span> <span class="o">&lt;</span> <span class="n">min</span> <span class="p">{</span>
            <span class="n">min</span> <span class="o">=</span> <span class="n">valueAt</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">min</span>
<span class="p">}</span>
<span class="k">func</span> <span class="p">(</span><span class="n">currentRow</span> <span class="n">row</span><span class="p">)</span> <span class="n">getAt</span><span class="p">(</span><span class="n">position</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">byte</span> <span class="p">{</span>
    <span class="c">//get the index</span>
    <span class="n">index</span> <span class="o">:=</span> <span class="n">position</span> <span class="o">/</span> <span class="m">2</span>
    <span class="c">//if the position is an odd number, the upper four bits store the counter value,</span>
    <span class="c">//else lower four bits store the counter value</span>
    <span class="n">shift</span> <span class="o">:=</span> <span class="p">(</span><span class="n">position</span> <span class="o">&amp;</span> <span class="m">0x01</span><span class="p">)</span> <span class="o">*</span> <span class="m">4</span>
    <span class="c">//perform the shift (shift would be either 0 or 4) </span>
    <span class="c">//perform an AND operation with 0x0f, which 00001111</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">currentRow</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="n">shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="m">0x0f</span>
<span class="p">}</span>
</code></pre></div></div> <p>Let’s understand how <a href="https://github.com/dgraph-io/ristretto">Ristretto</a> uses count-min sketch.</p> <h3 id="ristretto">Ristretto</h3> <p>Ristretto is a fast, concurrent golang cache library built with a focus on performance and correctness. Ristretto development team set the following requirements for the cache:</p> <ol> <li>It should support concurrency</li> <li>It should maintain a high cache-hit ratio</li> <li>It should be memory-bounded (limit to configurable max memory usage)</li> <li>It should scale well as the number of cores and goroutines increases</li> <li>It should scale well under non-random key access distribution (e.g. Zipf)</li> </ol> <p>One of the exciting requirements was “maintaining a high cache-hit ratio”. To achieve this goal, the development team implemented an LFU (least frequently used) based eviction policy called <a href="https://blog.dgraph.io/refs/TinyLFU%20-%20A%20Highly%20Efficient%20Cache%20Admission%20Policy.pdf">TinyLFU</a>.</p> <p>TinyLFU is an eviction-agnostic admission policy designed to improve hit ratios with very little memory overhead. The main idea is only to let in a new element if its estimate (/cost) exceeds the item being evicted. Ristretto implements <code class="language-plaintext highlighter-rouge">TinyLFU</code> using <code class="language-plaintext highlighter-rouge">count-min sketch</code> that uses <a href="#4-bit-counter">four-bit counter</a>.</p> <p>Let’s look at a code snippet from Ristretto.</p> <p>Ristretto’s <code class="language-plaintext highlighter-rouge">tinyLFU (policy.go)</code> references <code class="language-plaintext highlighter-rouge">cmSketch</code> which implements count-min sketch.</p> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">tinyLFU</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">freq</span>    <span class="o">*</span><span class="n">cmSketch</span>
    <span class="c">//fields omitted</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">tinyLFU</span> <span class="o">*</span><span class="n">tinyLFU</span><span class="p">)</span> <span class="n">Push</span><span class="p">(</span><span class="n">keys</span> <span class="p">[]</span><span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">key</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">keys</span> <span class="p">{</span>
        <span class="n">tinyLFU</span><span class="o">.</span><span class="n">Increment</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c">//code omitted</span>
<span class="k">func</span> <span class="p">(</span><span class="n">tinyLFU</span> <span class="o">*</span><span class="n">tinyLFU</span><span class="p">)</span> <span class="n">Increment</span><span class="p">(</span><span class="n">key</span> <span class="kt">uint64</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tinyLFU</span><span class="o">.</span><span class="n">freq</span><span class="o">.</span><span class="n">Increment</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
<span class="p">}</span>

<span class="c">//code omitted</span>
<span class="k">func</span> <span class="p">(</span><span class="n">tinyLFU</span> <span class="o">*</span><span class="n">tinyLFU</span><span class="p">)</span> <span class="n">Estimate</span><span class="p">(</span><span class="n">key</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">int64</span> <span class="p">{</span>
    <span class="n">hits</span> <span class="o">:=</span> <span class="n">tinyLFU</span><span class="o">.</span><span class="n">freq</span><span class="o">.</span><span class="n">Estimate</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">hits</span>
<span class="p">}</span>
</code></pre></div></div> <p>Any access to a key in an LFU-based caching solution should increment the frequency of the accessed key. Instead of implementing the accurate key access count, Ristretto decided to use an estimated access count.</p> <p>To increase the access count of a key, Ristretto batches the <code class="language-plaintext highlighter-rouge">gets</code> in a buffer. When the buffer is full, the buffered keys are handed off to a goroutine for incrementing their frequencies. This is why the <code class="language-plaintext highlighter-rouge">Push</code> method of <code class="language-plaintext highlighter-rouge">tinyLFU</code> receives a slice of keys of type <code class="language-plaintext highlighter-rouge">uint64</code> (<em>hash of the incoming keys</em>).</p> <p>The <code class="language-plaintext highlighter-rouge">Push</code> method results in incrementing the access frequency of the keys by invoking the <code class="language-plaintext highlighter-rouge">Increment</code> method on the <code class="language-plaintext highlighter-rouge">cmSketch</code> object. <code class="language-plaintext highlighter-rouge">cmSketch</code> (<code class="language-plaintext highlighter-rouge">sketch.go</code>) is an implementation of the count-min sketch.</p> <blockquote> <p>With Ristretto, keys are already hashed, so the type of the parameter for the key in all these methods is <code class="language-plaintext highlighter-rouge">uint64</code>.</p> </blockquote> <p><code class="language-plaintext highlighter-rouge">tinyLFU</code> also provides a method called <code class="language-plaintext highlighter-rouge">Estimate</code> responsible for estimating a given key’s frequency. To get the estimate, <code class="language-plaintext highlighter-rouge">tinyLFU</code> invokes the <code class="language-plaintext highlighter-rouge">Estimate</code> method on the <code class="language-plaintext highlighter-rouge">cmSketch</code> object and returns the estimated frequency of the key.</p> <h3 id="code">Code</h3> <p>The code for this article is available <a href="https://github.com/SarthakMakhija/probabilistic-data-structures/tree/main/frequency">here</a>.</p> <h3 id="references">References</h3> <ul> <li><a href="https://en.wikipedia.org/wiki/Count–min_sketch">Count-min sketch</a></li> <li><a href="https://florian.github.io/count-min-sketch/">Count-min sketch</a></li> <li><a href="https://github.com/dgryski/go-tinylfu/blob/master/cm4.go">Four bit counter</a></li> <li><a href="https://github.com/dgraph-io/ristretto">Ristretto</a></li> <li><a href="https://blog.dgraph.io/post/introducing-ristretto-high-perf-go-cache/">Ristretto design</a></li> </ul> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p><a href="https://www.geeksforgeeks.org/introduction-to-the-probabilistic-data-structure/">Probabilistic data structures</a> provide approximate answers to queries about a large dataset rather than exact answers. These data structures are designed to handle large amounts of data in real-time by making trade-offs between accuracy and time and space efficiency. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:2" role="doc-endnote"> <p><a href="https://en.wikipedia.org/wiki/Big_O_notation">Big O notation</a> In computer science, big O notation is used to classify algorithms according to how their run time or space requirements grow as the input size grows. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </section> <!-- Social media shares --> <div class="share-buttons"> <ul class="share-buttons"> <div class="meta">Share</div> <li> <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Ftech-lessons.in%2Fcount-min-sketch%2F" target="_blank" title=" Facebook"> <i class="fa fa-facebook-square fa-2x" aria-hidden="true"></i> <span class="sr-only">Share on Facebook</span> </a> </li> <li> <a href="https://twitter.com/intent/tweet?text=Count-min+sketch%20https%3A%2F%2Ftech-lessons.in%2Fcount-min-sketch%2F" target="_blank" title=""> <i class="fa fa-twitter-square fa-2x" aria-hidden="true"></i> <span class="sr-only">Tweet</span> </a> </li> <li> <a href="http://www.linkedin.com/shareArticle?mini=true&url=https://tech-lessons.in/count-min-sketch/&title=Count-min+sketch%20%7C%20tech-lessons.in&summary=&source=https://tech-lessons.in/count-min-sketch/" target="_blank" title=" LinkedIn"> <i class="fa fa-linkedin fa-2x" aria-hidden="true"></i> <span class="sr-only">Share on LinkedIn</span> </a> </li> </ul> </div> <!-- Tag list --> <footer> <div class="tag-list"> <div class="meta">Tags</div> <a class="button" href="/tags#Count-min+sketch"> <p><i class="fa fa-tag fa-fw"></i> Count-min sketch</p> </a> <a class="button" href="/tags#Probabilistic+data+structures"> <p><i class="fa fa-tag fa-fw"></i> Probabilistic data structures</p> </a> </div> </footer> </article> <!-- Disqus --> <div class="comments"> <div id="disqus_thread"></div> <script type="text/javascript"> var disqus_shortname = 'techlessons'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script> <noscript>Please enable JavaScript to view comments.</noscript> </div> <!-- Post navigation --> <div id="post-nav"> <div id="previous-post"> <a alt="Bloom filter" href="/bloom-filter/"> <p>Previous post</p> Bloom filter </a> </div> <div id="next-post"> <a alt="Invoking C Code from Golang" href="/invoking-C-code-from-golang/"> <p>Next post</p> Invoking C Code from Golang </a> </div> </div> <!-- To change color of links in the page --> <style> header#main { background-repeat:no-repeat; background-image: url('/assets/img/pexels/countminsketch-title.png'); } </style> </div> <footer class="site-footer"> <p class="text"> tech-lessons.in © 2020. All Rights Reserved. Powered by <a href='https://jekyllrb.com/'>Jekyll</a> </p> <div class="footer-icons"> <ul> <li> <a href="https://github.com/sarthakmakhija" title="Follow on GitHub"> <span class="fa-stack fa-lg"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i> </span> </a> </li> <li> <a href="https://www.linkedin.com/in/sarthak-makhija-7a165a55/" title="Follow on LinkedIn"> <span class="fa-stack fa-lg"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i> </span> </a> </li> </ul> <ul> </ul> </div> </footer> </body> </html>
