<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

	<!-- generator="WordPress/5.3.2" created="2020-03-28 06:45" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>tech-lessons.in</title>
	<link>http://tech-lessons.in</link>
	<description>tech lessons and learnings from a developer</description>
	<pubDate>Sat, 28 Mar 2020 06:45:04 +0000</pubDate>
	<language>en-US</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>http://tech-lessons.in</wp:base_site_url>
	<wp:base_blog_url>http://tech-lessons.in</wp:base_blog_url>

		<wp:author><wp:author_id>1</wp:author_id><wp:author_login><![CDATA[sarthakmakhija]]></wp:author_login><wp:author_email><![CDATA[sarthak.makhija@gmail.com]]></wp:author_email><wp:author_display_name><![CDATA[sarthakmakhija]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>

				
	<generator>https://wordpress.org/?v=5.3.2</generator>

		<item>
		<title>Kotlin Learnings</title>
		<link>http://tech-lessons.in/?p=353</link>
		<pubDate></pubDate>
		<dc:creator><![CDATA[sarthakmakhija]]></dc:creator>
		<guid isPermaLink="false">http://tech-lessons.in/?p=353</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>Kotlin is a cross-platform, statically typed programming language for modern multi-platform applications. I love Kotlin for its simplicity and after working on Kotlin for sometime I have started feeling that it is the simplicity at its core which makes it a beautiful language. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>I would like to share my learnings after working with Kotlin.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3>Being Idiomatic</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Kotlin provides a lot of idioms including <em>implicit lambda parameter, with, apply, when expression</em> etc which are useful in writing idiomatic code. Let’s take an example to understand some of the idioms better.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><em>Below is a function which takes a List&lt;T&gt; and converts to ByteArray using opencsv library.</em></p>
<!-- /wp:paragraph -->

<pre class="wp-block-code"><code>inline fun  toCsv(content: List): ByteArray {
    val headerMappingStrategy = HeaderColumnNameMappingStrategy()
    headerMappingStrategy.type = T::class.java

    val stringWriter = StringWriter()
    val beanToCsv =
        StatefulBeanToCsvBuilder(stringWriter)
            .withMappingStrategy(headerMappingStrategy)
            .withApplyQuotesToAll(false)
            .build()

    beanToCsv.write(content)
    return stringWriter.toString().toByteArray()
}</code></pre>

<!-- wp:paragraph -->
<p>The above code can be made more idiomatic using apply. Let’s make an attempt.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>We can use with(..) function passing StringWriter() as a receiver object and a lambda which operates on StringWriter().</p></blockquote>
<!-- /wp:quote -->

<pre class="wp-block-code"><code>inline fun  toCsv(content: List): ByteArray =
        with(StringWriter()) {
                val headerMappingStrategy = HeaderColumnNameMappingStrategy()
                headerMappingStrategy.type = T::class.java

                StatefulBeanToCsvBuilder(this)
                    .withMappingStrategy(headerMappingStrategy)
                    .withApplyQuotesToAll(false)
                    .build()
                    .write(content)

                return this.toString().toByteArray()
            }</code></pre>

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>Now, we can use apply {…} on HeaderColumnNameMappingStrategy. apply {..} is a function which takes a lambda that is an extension function on T and returns Unit.</p></blockquote>
<!-- /wp:quote -->

<pre class="wp-block-code"><code>inline fun  toCsv(content: List): ByteArray =
        with(StringWriter()) {
            StatefulBeanToCsvBuilder(this)
                .withMappingStrategy(HeaderColumnNameMappingStrategy().apply {
                    this.type = T::class.java
                })
                .withApplyQuotesToAll(false)
                .build()
                .write(content)

            return this.toString().toByteArray()
        }</code></pre>

<!-- wp:heading {"level":4} -->
<h4>Learnings</h4>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>Functions like with(..) and apply(…) help in reducing verbosity of the code and in creating expression functions.</li><li>It is good to keep a watch on overall readability of the code. We could use nested apply(..) or nested with(..) which might make the code look fancy but could be difficult to understand. E.g. If we were pairing while writing the above function and if you say <em>withMappingStrategy(..)</em> is getting difficult to understand, I would extract it into a separate single line expression function.</li></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":3} -->
<h3><br>Handling NULL&nbsp;values</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Kotlin shines when it comes to handling NULLs. It checks for NULLs at compile time thereby preventing <em>NullPointerException</em>.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>class Item(val name: String, val description: String?)
class Task(val description: String)

fun createTask(item: Item): Task? {
    return item.description?.let {
        Task(it)
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Above is an idiomatic way of creating a Task instance if “<em>item description</em>” is not null.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Learnings</h4>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>nullable fields make the domain model explicit. Let’s look at a simple example.</li></ul>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="wp-block-code"><code>class Iteration(private val no: String, private val startDate: LocalDate, private val endDate: LocalDate)

class Story(private val name: String, private val iteration: Iteration?)</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Above code explicitly highlights that a story might not be slotted in any iteration.</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Functions like <em>let(…)</em> help in writing idiomatic code without the need to write an if/else for null checking.</li><li>With Kotlin and Java code co-existing, compiler can not prevent <em>NullPointerException. </em>Let’s look at the example below, <em>name()</em> method of JavaClass returns null and when invoked from Kotlin compiler does not complain when toString() is invoked on name variable.</li></ul>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="wp-block-code"><code>public class JavaClass {
    public String name() {
        return null;
    }
}

fun main() {
    val name = JavaClass().name()
    println(name.toString()) 
    //compiler can not check if name is null
}</code></pre>
<!-- /wp:code -->

<!-- wp:heading {"level":3} -->
<h3><br>Extension functions</h3>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Kotlin supports extension functions, which provide an ability to extend a class with new functionality without having to inherit from the class or use any type of design pattern, such as Decorator.&nbsp;</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let’s write a function to find the last character on String.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>fun String.lastChar() = this.get(this.length - 1)</code></pre>
<!-- /wp:code -->

<!-- wp:heading {"level":4} -->
<h4>Learnings</h4>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>Extension functions come in handy while working with external libraries / classes with no ability to extend them. Let’s say we are working with <em>LocalDate</em> and we need a function <em>isSunday</em> on <em>LocalDate</em>.&nbsp;<br>One of the options is to extend <em>LocalDate</em> which is not possible because LocalDate does not expose a public constructor. Other option is to create an extension function on LocalDate. Let’s develop it.</li></ul>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="wp-block-code"><code>fun LocalDate.isSunday() = this.dayOfWeek == DayOfWeek.SUNDAY

fun main() {
  println(LocalDate.now().isSunday())
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":3} -->
<h3 id="mce_46">Functional</h3>
<!-- /wp:heading -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>353</wp:post_id>
		<wp:post_date><![CDATA[2020-03-12 15:16:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="kotlin"><![CDATA[Kotlin]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[classic-editor-remember]]></wp:meta_key>
		<wp:meta_value><![CDATA[block-editor]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[inherit]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[16]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[90]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Humanizing Code</title>
		<link>http://tech-lessons.in/?p=468</link>
		<pubDate>Sat, 05 Oct 2019 07:31:21 +0000</pubDate>
		<dc:creator><![CDATA[sarthakmakhija]]></dc:creator>
		<guid isPermaLink="false">http://tech-lessons.in/?p=468</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>The idea behind Humanizing code is to introduce a human angle in the code which effectively means asking simple questions - </p><p>"What if this code were human?", "Would I be giving same name to a method if it were human and I wanted to talk to it?", "What would I be doing differently if my code were to become human some day?"</p></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Let's see what exactly is humanizing code and how does it relate to writing code that we can have a conversation with.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>What exactly is humanizing code?</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Well, in simple terms, it is all about treating code as human and having a conversation with the code like we would have in real life. Let's look at a method which is defined in some class say <em>EmployeeService</em> - </p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>private fun isSeniorCitizen(employee: Employee) = employee.age > 60</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>This method is simple and easy to understand but not close to real life, probably not human. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In real life, I will most likely ask an employee, "Hey, are you a senior citizen?" which means this method might be placed differently -</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>class Employee(private val age: Int) {
    fun isSeniorCitizen() = age > 60
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Now my code is doing the same thing that I would have done in real life. In fact the invocation of this method looks closer to real world - <em><strong>anEmployee.isSeniorCitizen()</strong></em></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What is interesting about this theory is that it brings in another perspective of looking at the code. </p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>Code is written for humans by humans, why not make code itself a human.</p></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Let's try and find out various aspects around humanizing code.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Is the code closer to real life?</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Code is read more often that it is written which means it becomes really important to ensure that our code conveys its intent. Along with the intent if code can be brought closer to real life it might be easier to understand and relate to. You never know, readers of the code might thank you for making their lives simpler. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's look at an example - </p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>class User(private val id: String)
class Employee(val age: Int)
class EmployeeAdditionRequest(val employees: List&lt;Employee>, 
                              private val requestedBy: User)

fun add(employeeAdditionRequest: EmployeeAdditionRequest) {
    val employees = employeeAdditionRequest.employees.filter {
        it.age > 60
    }
    //call some method which adds employees
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>This simple code provides a method called <code>add</code> which takes an <code>EmployeeAdditionRequest</code> containing a list of employees and a reference to a user who attempts to perform this request. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><code>add(..)</code> is a method which filters employees based on a condition and calls some method which does the actual addition.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's try and see what do we think as a reader of this code. As a reader -</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>I can't figure out what is <em>&gt; 60</em> trying to convey</li><li><code>add(...)</code> with a parameter of type <code>EmployeeAdditionRequest</code> sounds a little weird. I feel <code>add</code> method should be better named as <code>perform</code> or <code>execute</code> to make it more human like - <code>execute(anEmployeeAdditionRequest: EmployeeAdditionRequest)</code></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Let's try and refactor this  -</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>fun execute(anEmployeeAdditionRequest: EmployeeAdditionRequest) {
    val employees = anEmployeeAdditionRequest.employees.filter {
        isSeniorCitizen(it)
    }
    //call addition of employees..
}
private fun isSeniorCitizen(it: Employee) = it.age > 60</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Slightly better and human like, at least I get to know that we are filtering senior citizens. But, there definitely is a scope for helping our readers. As a reader -</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>I feel <code>isSeniorCitizen</code> taking an employee looks strange. It would be more natural if our code could be more like our real life. In our real life, we would ask an employee "Hey, are you a senior citizen?" which should translate to "is an employee a senior citizen?" in the code, which means the method <code>isSeniorCitizen</code> should move to <code>Employee</code></li></ul>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="wp-block-code"><code>class Employee(private val age: Int) {
    fun isSeniorCitizen() = age > 60
}
fun execute(anEmployeeAdditionRequest: EmployeeAdditionRequest) {
    val employees = anEmployeeAdditionRequest.employees.filter {
        it.isSeniorCitizen()
    }
    //call addition of employees..
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Better than the original code. As a reader, I can <em>figure out</em> that we are trying to filter all the employees who are senior citizens. But, if that is the case, can our code be more explicit about this. Let's see - </p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>fun execute(anEmployeeAdditionRequest: EmployeeAdditionRequest) {
    val seniorCitizenEmployees = 
           anEmployeeAdditionRequest.allSeniorCitizenEmployees() (*)
    //call addition of employees..
}

class EmployeeAdditionRequest(
private val employees: List&lt;Employee>, 
private val requestedBy: User) {

    fun allSeniorCitizenEmployees(): List&lt;Employee> {
        return employees.filter { it.isSeniorCitizen() }
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Now, as a reader I know - </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>The code is trying to execute <code>anEmployeeAdditionRequest</code></li><li>As a part of this request, all senior citizen employees are found</li><li>A senior citizen employee is someone with age &gt; 60</li><li>There is one thing that I would like to think about - "Is <code>allSeniorCitizenEmployees</code> an appropriate name?". I am not sure. I feel, given <em>anEmployeeAdditionRequest</em>, I would like to ask, "Hey, give me all senior citizens", instead of saying, "Hey, give me all senior citizen employees". If this were real code, I would add it to my TODO list and revisit later.</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>I have realized that a few things help me in writing "<em>reader friendly</em>" code. </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>I read my code a lot while writing. This helps me ask various questions to myself including - is my code conveying the meaning, how would something happen in real life, if this method were human how would I be talking to it </li><li>Focussing on domain terms like "<em>SeniorCitizen</em>" and avoiding terms like <code>info, data, details </code>in the code keep me aligned towards figuring out domain centric terminology</li><li>Quick check to see that I am not breaking encapsulation like in the initial code wherein list of employees was exposed from <code>EmployeeAdditionRequest</code></li><li>Maintaining a good TODO list</li></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":4} -->
<h4>Are the tests closer to real life?</h4>
<!-- /wp:heading -->

<!-- wp:paragraph {"align":"left"} -->
<p style="text-align:left">Tests are an important part of any application, they serve as documentation, act as safety net and provide "release ready confidence" to everyone in the team. If they are doing so much for us, they should definitely be conveying the intent and as it goes, they should be closer to real life.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Are the names closer to real life?</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We often use terms like <code>info, data, details </code>in the code. We don't even shy away from using abbreviations in the code - in variable names, in method names, in fact in many different places. We use unpronounceable names in the code. We do everything we can to ensure that our code is not at all close to real life.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Well, we are humans and our parents could have named us the same way but they didn't. Why not spend a little more time and give a name which is intent revealing and for sure <code>info, data, details</code> don't seem to reveal any intent.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>class PolicyService {
    fun findTotPremDue(policyNumber: String) {
        //returns the total premium due 
    }
    fun findPolicyInfo(policyNumber: String){        
       //return the policy information
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>As a reader, I can't even pronounce <code>findTotPremDue(...)</code>. Applying human theory to it, </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>I feel <code>findTotalPremiumDue(...)</code> sounds better</li><li>Technically, <code>findTotalPremiumDue(policyNumber: String)</code> might look ok, but I have a feeling (yes, a feeling) <code>findTotalPremiumDue(for: PolicyNumber)</code> looks more natural. In this very case we are introducing a new object (PolicyNumber) and I might want to defer this decision until I am sure this is what I need</li></ul>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="wp-block-code"><code>class PolicyService {
   //Option - 1 
   fun findTotalPremiumDue(policyNumber: String) {
        //returns the total premium due 
    }
    //Option - 2
    fun findTotalPremiumDue(`for`: PolicyNumber) {
        //returns the total premium due 
    }
    fun findPolicyInfo(policyNumber: String){        
       //return the policy information
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Coming to <code>findPolicyInfo(...)</code>, as a reader I am not sure if "<em>info</em>" is adding any special value. I can think of 2 things in this case - </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Remove <em>info</em> and just say <code>findPolicy(for: PolicyNumber) </code>or <code>findPolicy(belongingTo: PolicyNumber)</code></li><li>Introduce a domain terminology like <em>Snapshot or View</em> early in the discussions so that everyone including the business starts using these terms in all the conversations instead of <em>info</em>. If this gets agreed upon, then the method could become <code>findPolicySnapshot(for: PolicyNumber)</code></li></ul>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="wp-block-code"><code>class PolicyService {
    //Option - 1 
    fun findTotalPremiumDue(policyNumber: String) {
        //returns the total premium due 
    }
    //Option - 2
    fun findTotalPremiumDue(`for`: PolicyNumber) {
        //returns the total premium due 
    }

    //Option - 1
    fun findPolicy(`for`: PolicyNumber){        
       //returns the policy
    }
    //Option - 2
    fun findPolicySnapshot(`for`: PolicyNumber){        
       //returns the policy snapshot
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>I think this is it for now. I would like to close this article with a quick summary highlighting the relationship with Refactoring and Humanizing code.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Summary</h4>
<!-- /wp:heading -->

<!-- wp:image {"id":624,"align":"center","width":457,"height":347} -->
<div class="wp-block-image"><figure class="aligncenter is-resized"><img src="http://tech-lessons.in/wp-content/uploads/2019/10/Humanize-Code-2.png" alt="Humanize Code along with Refactoring" class="wp-image-624" width="457" height="347"/><figcaption><em>Humanizing Code along with Refactoring</em></figcaption></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>In order to refactor code, we identify code smells and then apply refactoring techniques. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph {"align":"left"} -->
<p style="text-align:left">Humanizing code just introduces <em>human angle in the code</em> which ultimately ties back to some refactoring techniques like the one we saw in movement of <em>isSeniorCitizen</em> method to <em>Employee</em> class which is nothing but <em>"Move Method" </em>refactoring technique. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>There are times when I feel this non-technical perspective combined with refactoring techniques makes it easier for me to identify code smells. I have been experimenting with this theory and honestly enjoying it. May be, it might help me in understanding the relationship between software development and human behavior better.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>468</wp:post_id>
		<wp:post_date><![CDATA[2019-10-05 07:31:21]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2019-10-05 07:31:21]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="category" nicename="clean-code"><![CDATA[Clean Code]]></category>
		<category domain="post_tag" nicename="clean-code"><![CDATA[clean code]]></category>
		<category domain="post_tag" nicename="refactoring"><![CDATA[Refactoring]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[classic-editor-remember]]></wp:meta_key>
		<wp:meta_value><![CDATA[block-editor]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[inherit]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[27]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[30]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[624]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Beginning Serverless Journey</title>
		<link>http://tech-lessons.in/?p=645</link>
		<pubDate></pubDate>
		<dc:creator><![CDATA[sarthakmakhija]]></dc:creator>
		<guid isPermaLink="false">http://tech-lessons.in/?p=645</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:quote -->
<blockquote class="wp-block-quote"><p>Serverless is a paradigm which lays its foundations on the fact that "We don't have to provision and manage servers". </p><p>This article series explores various aspects involved in a serverless application lifecycle including - development, testing and deployment.</p><p>Our serverless journey which starts from building to deploying an application will be using multiple serverless components including AWS Lambda, AWS API Gateway, AWS DynamoDB, LocalStack and AWS CDK.</p></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>Let's deep dive step by step into what it takes to build a Serverless application.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Building a Serverless application</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's assume a hypothetical "<em>Order Service</em>" that allows creation of an order and its retrieval by id.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>As a part of this article we will be building just one part of this service which will expose a REST API to allow users to "<em>find an order</em>" by "<em>orderId</em>".  Below diagram highlights different AWS components involved in finding an order by its id.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1126,"sizeSlug":"large","className":"is-style-default"} -->
<div class="wp-block-image is-style-default"><figure class="aligncenter size-large"><img src="https://tech-lessons.in/wp-content/uploads/2020/03/Untitled-Diagram-6.png" alt="" class="wp-image-1126"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>We will be using TypeScript for writing our Serverless application. Why Typescript? For a few reasons - </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Small cold start time</li><li>Supports static typing and type inference</li><li>Existing Javascript libraries can be used with Typescript</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>So, let's start building our application. </p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Step 1: Setting up the project</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's quickly setup our project -</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Install typescript globally by executing <code>npm install typescript -g</code></li><li>Create a directory named <code>serverless-order-service</code> representing our project</li><li>Execute <code>npm init -y</code> inside our project directory (<code>serverless-order-service</code>)</li><li>Add typescript as a dependency by executing <code>npm install typescript --save</code> inside our project directory</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>As a final step, add <code>tsconfig.json</code> with a very simple configuration as mentioned below -</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">{
  "compilerOptions": {
    "noEmitOnError": true,
    "moduleResolution": "node",
    "module": "commonjs",
    "target": "es6",
    "outDir": "dist",
    "inlineSourceMap": true
  }
}</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>That should be it. Our project set up is done and we are ready to make our first commit.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Before we start coding</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's take a moment to think about the overall design of the project. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This application is a classic web application which involves a REST API, a database and an object representing the persistent state of order. With this very small context, I feel it would not be unfair to organise the project in <em>Model-View-Controller</em> fashion which means execution of a user request will involve the following components - </p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1041,"sizeSlug":"large"} -->
<div class="wp-block-image"><figure class="aligncenter size-large"><img src="https://tech-lessons.in/wp-content/uploads/2020/03/Handler-Controller-Service-Repo.png" alt="" class="wp-image-1041"/></figure></div>
<!-- /wp:image -->

<!-- wp:heading {"level":4} -->
<h4>Step 2: Let's start with lambda handler</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Lambda handler is a function which will be invoked by <em>AWS Lambda Service</em> in response to an event. An event could be - an object uploaded on an S3 bucket, an event on SQS or an https request via API gateway and many more. In our example a request to an API Gateway will be an event.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Before we start our lambda function let's install type definition for aws-lambda by executing - <code>npm install @types/aws-lambda --save-dev</code> and create a commit.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>After the dependency is installed we are ready to code our handler. Let's put this in a file named <code>handler.ts</code> under <code>src</code> directory.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {APIGatewayEvent} from "aws-lambda";
export const ordersHandler = async (event: APIGatewayEvent): Promise&lt;any> => {
     //your code goes here
};</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>This is the simplest handler function that could be created at this stage. One thing to note is we are using the type <em>APIGatewayEvent</em> imported from <em>"aws-lambda"</em> to get type-safe events as parameter to handler function.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We want to keep our handler function as thin as possible so we will delegate the request to a controller class which instead of taking <em>APIGatewayEvent</em> will take a domain object that wraps <em>APIGatewayEvent</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In this example, <em>OrderRequest</em> is that domain object, effectively a wrapper over <em>APIGatewayEvent</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {APIGatewayEvent} from "aws-lambda";

export const ordersHandler = async (event: APIGatewayEvent): Promise&lt;any> => {
    return new OrderController().handle(new OrderRequest(event)); //invoke controller
};

export class OrderController {
    handle(orderRequest: OrderRequest) {
    }
}

export class OrderRequest {
    constructor(private readonly event: APIGatewayEvent) {
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Let's move OrderController and OrderRequest classes to <em>controller</em> and <em>model</em> packages (or directories) respectively and invoke OrderController from handler. This is how the handler function will look like after the classes have been moved.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {APIGatewayEvent} from "aws-lambda";
import {OrderRequest}    from "./model/OrderRequest";
import {OrderController} from "./controller/OrderController";

export const ordersHandler = async (event: APIGatewayEvent): Promise&lt;any> => {
    return new OrderController().handle(new OrderRequest(event));
};</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>I think we are ready to make our next commit. I know we haven't written any unit tests but as far as this article is concerned, we will write unit tests before we start the next one.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Step 3: Let's jump into controller</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Controller is a class which will handle the incoming request and return an appropriate response. By this definition, controller will be expected to accept an OrderRequest and find an order by its id.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {OrderRequest} from "../model/OrderRequest";

export class OrderController {

    handle(orderRequest: OrderRequest) {
       if (orderRequest.isAGetOrder()) {
         return this.findAnOrderBy(orderRequest.orderId())
       }
       return null;
    }

    private findAnOrderBy(id: string): Order {
        return null;
    }
}

export class Order {
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Few quick observations - </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>OrderRequest is the domain object which encapsulates APIGatewayEvent and provides domain methods like orderId(), isAGetOrder() without exposing <em>APIGatewayEvent</em></li><li>Currently orderId() and isAGetOrder() methods of OrderRequest return fixed (or fake) values</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Let's make a few quick changes in OrderController -</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Move Order class into model package</li><li>Invoke Service method to find an order by its id</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>This is how different classes look at this stage.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><span style="text-decoration: underline;">OrderController.ts</span></p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {OrderRequest} from "../model/OrderRequest";
import {Order}        from "../model/Order";
import {OrderService} from "../service/OrderService";

export class OrderController {
    private orderService: OrderService;

    constructor() {
        this.orderService = new OrderService();
    }

    handle(orderRequest: OrderRequest) {
       if (orderRequest.isAGetOrder()) {
         return this.findAnOrderBy(orderRequest.orderId())
       }
       return null;
    }

    private findAnOrderBy(id: string): Order {
        return this.orderService.findAnOrderBy(id); //invoke service
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><span style="text-decoration: underline;">OrderRequest.ts</span></p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {APIGatewayEvent} from "aws-lambda";

export class OrderRequest {
    constructor(private readonly event: APIGatewayEvent) {
    }

    isAGetOrder(): boolean {
       return true;
    }
    orderId(): string {
        return "";
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><span style="text-decoration: underline;">OrderService.ts</span></p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>export class OrderService {

    findAnOrderBy(id: string) {
        return null;
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:heading {"level":4} -->
<h4>Step 4: Let's jump into service</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Service layer will interact with repository to find an order by id. It doesn't look like service layer is really needed for this example, but let's proceed with it -</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>export class OrderService {
    private repository: OrderRepository;

    constructor() {
        this.repository = new OrderRepository();
    }

    findAnOrderBy(id: string) {
        return this.repository.findAnOrderBy(id); //invoke repository
    }
}

export class OrderRepository {
    findAnOrderBy(id: string) {
        return null;
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Let's move OrderRepository into repository package.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Step 5: Let's jump into repository</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Repository will interact with our database which in this example is a DynamoDB and fetch an order by its id. Let's assume a table named "<em>orders</em>" with "<em>orderId</em>" as the HASH key. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We will be using "<em>aws-sdk</em>" for querying DynamoDB. "aws-sdk" is a dependency which is available in the runtime environment of lambda which means this dependency can be added as a "<em>devDependency</em>".</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, let's add it as a "devDependency" by executing <code>npm install aws-sdk --save-dev</code>. Let's also add type definitions for aws-sdk by executing <code>npm install @types/aws-sdk --save-dev</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Now we are ready to query "orders" table.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {DynamoDB} from "aws-sdk"
import {GetItemInput} from "aws-sdk/clients/dynamodb";
import {Order} from "../model/Order";

const dynamoDb = new DynamoDB({
    "region": "ap-south-1"
});

export class OrderRepository {

    async findAnOrderBy(id: string) {
        const getItemInputOptions: GetItemInput = {
            TableName: "orders",
            Key: {
                "orderId": {S: id}
            }
        };
        const response = await dynamoDb.getItem(getItemInputOptions).promise();
        return response.Item;
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Few quick observations - </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>We have hard-coded the region and table name, which we might want to fetch from configuration / properties for below mentioned reasons -<ul><li>if <em>region</em> is different for actual deployment and integration testing (using localstack)</li><li> if there are multiple deployment environments and dynamo table name is different for each environment<ul><li>With DynamoDB lowest level of abstraction is a table, hence, we might need different table name for each environment</li></ul></li></ul></li><li>Method name and return type of the method do not go hand-in-hand. We expect this method to return an "<em>order</em>" but this method seems to be returning some type specified by <em>"response.Item"</em></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Let's quickly make a change to return <em>Order instead of response.Item. </em></p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {DynamoDB} from "aws-sdk"
import {GetItemInput} from "aws-sdk/clients/dynamodb";
import {Order} from "../model/Order";

const dynamoDb = new DynamoDB({
    "region": "ap-south-1"
});

export class OrderRepository {

    async findAnOrderBy(id: string) {
        const getItemInputOptions: GetItemInput = {
            TableName: "orders",
            Key: {
                "orderId": {S: id}
            }
        };
        //get an item from dynamoDb
        const response = await dynamoDb.getItem(getItemInputOptions).promise(); 
        return response.Item ? Order.from(response.Item) : null;
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>and this is how Order.ts looks like - </p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {DocumentClient} from "aws-sdk/clients/dynamodb";

export class Order {
    static from(item: DocumentClient.AttributeMap): Order {
        return null;
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>This completes our repository. We still have some open items. Let's take them one by one - </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Pending implementation of <em>from()</em> in <em>Order</em></li><li>Pending implementation of <em>orderId()</em> in <em>OrderRequest</em></li><li>Pending changes relating to async/await in controller, service and handler</li></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":4} -->
<h4>Step 6: Finishing Order class</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Order class provides a static method which accepts and instance of DocumentClient.AttributeMap and returns an instance of Order. To keep things simple, we will assume that an order has orderId and amount.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {DocumentClient} from "aws-sdk/clients/dynamodb";

export class Order {  

    static from(item: DocumentClient.AttributeMap): Order {
        return new Order(item.orderId.S, Number(item.amount.N));
    }
    private constructor(private readonly orderId: string,
                        private readonly amount: number) {
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><code>AttributeMap within aws-sdk </code>is defined as -</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>export type AttributeMap = {[key: string]: AttributeValue};</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>and AttributeValue is an interface which is defined as -</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>export interface AttributeValue {
    S?: StringAttributeValue;
    N?: NumberAttributeValue;
  .....
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Hence, <code>item.orderId</code> gives us an instance of <code>AttributeValue</code> and then we use <code>.S or .N</code> to get the corresponding value</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Step 7: Finishing OrderRequest class</h4>
<!-- /wp:heading -->

<!-- wp:list -->
<ul><li>isAGetOrder() should return TRUE given a GET request beginning with /orders as the path part</li><li>orderId() should return the value of pathParameter "orderId"</li></ul>
<!-- /wp:list -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {APIGatewayEvent} from "aws-lambda";

export class OrderRequest {
    constructor(private readonly event: APIGatewayEvent) {
    }

    isAGetOrder(): boolean {
        return this.event.httpMethod === "GET" &amp;&amp;
               this.event.path.startsWith("/orders") &amp;&amp;
               this.event.pathParameters.orderId != null;
    }
    orderId(): string {
        return this.event.pathParameters.orderId;
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:heading {"level":4} -->
<h4>Step 8: Introducing async/await in service and controller</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's introduce async and await in handler, controller and service.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>//handler.ts
export const ordersHandler = async (event: APIGatewayEvent): Promise&lt;any> => {
    return await new OrderController().handle(new OrderRequest(event));
};

//OrderController.ts
async handle(orderRequest: OrderRequest) {
    if (orderRequest.isAGetOrder()) {
        return await this.findAnOrderBy(orderRequest.orderId())
    }
    return null;
}

private async findAnOrderBy(id: string) {
    return await this.orderService.findAnOrderBy(id);
}

//OrderService.ts
async findAnOrderBy(id: string) {
    return await this.repository.findAnOrderBy(id);
}</code></pre>
<!-- /wp:code -->

<!-- wp:heading {"level":4} -->
<h4>Step 9: Lambda response with API gateway</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>When AWS lambda works behind an API gateway, it is expected to return a response in a specific format. This looks like -</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>{
   "statusCode": Http Status Code,
   "body": Response body,
   "headers": Response headers
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>It would be great if controller knows the least about this structure. All it should do is return a response with Order object. Let's create an abstraction which takes an object T and knows about the final HTTP response. Let's name this as <em>Response</em>.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>export class Response&lt;T> {
    private constructor(readonly status: HttpStatus, readonly body?: T) {
    }

    static ok&lt;T>(status: HttpStatus, body?: T) {
        return new Response(status, body);
    }
    static notFound() {
        return new Response(HttpStatus.NOT_FOUND);
    }
}

export class HttpStatus {
    static readonly OK = "200";
    static readonly NOT_FOUND = "404";
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>With the introduction of Response, following will be the view of some classes - </p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {OrderRequest} from "../model/OrderRequest";
import {OrderService} from "../service/OrderService";

export class OrderController {
    private orderService: OrderService;

    constructor() {
        this.orderService = new OrderService();
    }

    async handle(orderRequest: OrderRequest): Promise&lt;Response&lt;Order | unknown>> {
        if (orderRequest.isAGetOrder()) {
            const order = await this.findAnOrderBy(orderRequest.orderId());
            return Response.ok&lt;Order>(HttpStatus.OK, order); //return Ok
        }
        return Response.notFound(); //return NotFound
    }

    private async findAnOrderBy(id: string) {
        return await this.orderService.findAnOrderBy(id);
    }
}

export class Response&lt;T> {
    private constructor(readonly status: HttpStatus, readonly body?: T) {
    }

    static ok&lt;T>(status: HttpStatus, body?: T) {
        return new Response(status, body);
    }
    static notFound() {
        return new Response(HttpStatus.NOT_FOUND);
    }
    get() {
        //return JSON response
        return this.body === null ? {"statusCode": this.status} : {
            "statusCode": this.status,
            "body": JSON.stringify(this.body)
        }
    }
}

export class HttpStatus {
    static readonly OK = "200";
    static readonly NOT_FOUND = "404";
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>If controller returns an instance of Response, handler code can be changed to invoke get() on the returned instance.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {APIGatewayEvent} from "aws-lambda";
import {OrderRequest}    from "./model/OrderRequest";
import {OrderController} from "./controller/OrderController";

export const ordersHandler = async (event: APIGatewayEvent): Promise&lt;any> => {
    const response = await new OrderController().handle(new OrderRequest(event));
    return response.get();
};</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>That's it. We have connected all the pieces, yes without any form of tests.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Step 10: Adding unit tests</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's add a couple of unit tests before we close the article. I will add all the necessary unit tests offline and commit the code. Before we can start with tests let's add following dependencies -</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>npm install <code>jest</code> --save-dev</li><li>npm install <code>@types/jest</code> --save-dev</li><li>npm install <code>ts-jest</code> --save-dev</li><li>npm install <code>sinon</code> --save-dev</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>jest configuration in <code>jest.config.js</code> -</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>module.exports = {
    "testMatch": [
        "**/__tests__/**/*.+(ts|tsx|js)",
        "**/?(*.)+(spec|test).+(ts|tsx|js)"
    ],
    "transform": {
        "^.+\\.(ts|tsx)$": "ts-jest"
    },
};</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>test script in <code>package.json</code> -</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">"scripts": {
  "test": "jest test/**"
}</pre>
<!-- /wp:preformatted -->

<!-- wp:heading {"level":4} -->
<h4>Controller unit tests</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's add our first test which attempts to validate the status for finding an order by its id.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {OrderController} from "../../src/controller/OrderController";
import {OrderRequest} from "../../src/model/OrderRequest";
import {APIGatewayEvent} from "aws-lambda";
import {HttpStatus} from "../../src/model/ModelAndResponseStatus";
import {OrderService} from "../../src/service/OrderService";
import {Order} from "../../src/model/Order";

import * as sinon from "sinon";

test("should return Ok as the response status given a request to find an order by id", async () =>{
    sinon.stub(OrderService.prototype, "findAnOrderBy")
         .callsFake(() => sinon.mock(Order));

    const response = await new OrderController().handle(orderRequest("id-100"));

    expect(response.status).toEqual(HttpStatus.OK);
});

afterEach(() => {
    sinon.restore();
});

const orderRequest = (id: string) => {
    const apiGatewayEvent: APIGatewayEvent = {
        httpMethod: "GET",
        path: `/orders/${id}`,
        pathParameters: {
            "orderId": id
        },
        body: null,
        isBase64Encoded: false,
        headers: {},
        multiValueHeaders: {},
        queryStringParameters: {},
        multiValueQueryStringParameters: {},
        stageVariables: {},
        requestContext: null,
        resource: ""
    };
    return new OrderRequest(apiGatewayEvent);
};</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>One quick observation -</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>apiGatewayEvent had to be constructed with all the attributes even though we needed only pathParameters because <em>APIGatewayEvent</em> type mandates all the attributes</li><li>visibility of status and model (in the next test) had to be changed from private to public to assert on these fields</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Another test could be to check the order returned from controller given an id.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>test("should return an order given a request to find an order by id", async () => {
    sinon.stub(OrderService.prototype, "findAnOrderBy")
         .callsFake(() => new Order("id-100", 1445));

    const response = await new OrderController().handle(orderRequest("id-100"));

    expect(response.body!!).toEqual(new Order("id-100", 1445));
});</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>I guess we are ready to do TDD as well for Serverless.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Summary</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Finally we have come to an end of our first article where we made an attempt to design a small part of a serverless application which uses AWS Lambda, API Gateway and DynamoDB.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>As a part of this application we have tried to draw some parallels with MVC design pattern and bring the same to the serverless world.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Items that we have left -</strong></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Exception handling is missing</li><li>Controller checks if the request is for getting an order. This if/else ladder will grow given the same lambda handles creation and deletion of orders.</li><li>Every component is unit testable in itself, except Repository layer which needs dynamo db</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p><strong>There is a lot of work still left before we can deploy the code -</strong></p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>We need to have integration test(s) which can give us confidence if this entire application is actually working or not</li><li>We need to integrate CDK (Cloud Development Kit) for deploying our infrastructure</li><li>We need to have unit tests and snapshot tests for our CDK based infra code</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Code is available <a href="https://github.com/aws-articles/serverless-order-service">here</a>. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's move on to our <a href="https://tech-lessons.in/testing-serverless-journey">next</a> article which explores integration testing using Localstack for our serverless application.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>645</wp:post_id>
		<wp:post_date><![CDATA[2020-03-17 05:21:18]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="aws-lambda"><![CDATA[AWS Lambda]]></category>
		<category domain="category" nicename="serverless"><![CDATA[Serverless]]></category>
		<category domain="post_tag" nicename="serverless"><![CDATA[Serverless]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[classic-editor-remember]]></wp:meta_key>
		<wp:meta_value><![CDATA[block-editor]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[inherit]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[29]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[30]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Concluding Serverless Journey</title>
		<link>http://tech-lessons.in/?p=790</link>
		<pubDate></pubDate>
		<dc:creator><![CDATA[sarthakmakhija]]></dc:creator>
		<guid isPermaLink="false">http://tech-lessons.in/?p=790</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>We have come a long way in our <a href="https://tech-lessons.in/beginning-serverless-journey">serverless journey</a>. This journey which started with building a serverless application has finally come to a stage where we can see all our hard work in action. Yes, we will be deploying our application.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We will be using <a href="https://docs.aws.amazon.com/cdk/latest/guide/home.html">AWS CDK</a> to deploy our application. Before we start using CDK, let's quickly look at what is CDK -</p>
<!-- /wp:paragraph -->

<!-- wp:group -->
<div class="wp-block-group"><div class="wp-block-group__inner-container"><!-- wp:quote {"align":"left"} -->
<blockquote class="wp-block-quote has-text-align-left"><p>The AWS Cloud Development Kit (AWS CDK) is an open source software development framework to model and <strong>provision your cloud application resources using familiar programming languages.</strong></p><p>Provisioning cloud applications can be a challenging process that requires you to perform manual actions, write custom scripts, maintain templates, or learn domain-specific languages. </p><p>AWS CDK uses the familiarity and <strong>expressive power of programming languages for modeling your applications</strong>. It provides you with high-level components that preconfigure cloud resources with proven defaults, so you can build cloud applications without needing to be an expert. </p><p><strong>AWS CDK provisions your resources in a safe, repeatable manner through AWS CloudFormation</strong>. It also enables you to <strong>compose and share your own custom components</strong> that incorporate your organization's requirements, helping you start new projects faster. <br><a href="https://aws.amazon.com/cdk/">https://aws.amazon.com/cdk/</a></p></blockquote>
<!-- /wp:quote --></div></div>
<!-- /wp:group -->

<!-- wp:paragraph -->
<p>In summary, we don't have to directly deal with CloudFormation or SAM for deploying our application. We will provision our cloud resources using a higher level framework called CDK which will ultimately translate into a CloudFormation template. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We should be able to see the advantages of using CDK very soon but let's look at this conversation to get some understanding of CDK.</p>
<!-- /wp:paragraph -->

<!-- wp:core-embed/youtube {"url":"https://youtu.be/W8sibGJnHEM","type":"video","providerNameSlug":"youtube","className":"wp-embed-aspect-16-9 wp-has-aspect-ratio"} -->
<figure class="wp-block-embed-youtube wp-block-embed is-type-video is-provider-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper">
https://youtu.be/W8sibGJnHEM
</div></figure>
<!-- /wp:core-embed/youtube -->

<!-- wp:paragraph -->
<p>Let's begin now.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Step 1: Setting up the project</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We will be using the same project which was pushed <a href="https://github.com/aws-articles/serverless-order-service">here</a>. </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Install CDK globally by executing <code>npm install aws-cdk -g</code></li><li>Create a directory named <code>infra</code> inside our project serverless-order-service</li><li>Execute <code>cdk init app --language=typescript</code> inside <code>infra</code> directory</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>This should generate a project which uses <code>typescript</code> as the programming language and <code>jest</code> as a testing framework. Let's update the generated <code>jest.config.js</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Below is how our jest.config.js will look like -</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>module.exports = {
    "testMatch": [
        "**/__tests__/**/*.+(ts|tsx|js)",
        "**/?(*.)+(spec|test).+(ts|tsx|js)"
    ],
    "transform": {
        "^.+\\.(ts|tsx)$": "ts-jest"
    },
};</code></pre>
<!-- /wp:code -->

<!-- wp:image {"align":"left","id":878,"width":277,"height":381,"sizeSlug":"large","className":"is-style-default"} -->
<div class="wp-block-image is-style-default"><figure class="alignleft size-large is-resized"><img src="https://tech-lessons.in/wp-content/uploads/2020/03/Screenshot-2020-03-13-at-10.25.17-PM-745x1024.png" alt="" class="wp-image-878" width="277" height="381"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>If all has gone well so far this how our project structure will look like -</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li><em>infra-stack.ts</em> defines a class called <em>InfraStack</em> which is going to be a logical collection of various constructs like lambda function(s), dynamodb etc</li><li><em>infra.ts</em> is the entry point of the application which creates an instance of InfraStack</li><li><em>infra.test.ts</em> contains a simple test to assert an empty stack</li><li><em>package.json</em> contains the project definition along with various dependencies including <em>@aws-cdk/assert</em> which is a library for asserting various cloud resources</li><li><em>jest.config.js </em>contains the necessary configuration to run jest tests</li><li><em>cdk.json </em>contains the command to run cdk application</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p><br>Let's make a few quick changes to the file names to match our convention, run the test and commit the changes -</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Rename infra.ts to OrderServiceInfra.ts</li><li>Rename infra-stack.ts to OrderServiceInfraStack.ts</li><li>Rename infra.test.ts  to OrderServiceInfraStack.spec.ts</li></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":4} -->
<h4>Step 2: Creating stack with lambda function</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's provision our lambda function. In order to do so we need to add a dependency <code>@aws-cdk/aws-lambda</code>. So, let's add it by executing <code>npm install @aws-cdk/aws-lambda@1.19.0</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We will start by creating a lambda function construct inside OrderServiceInfraStack.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import * as cdk from "@aws-cdk/core";
import {Function} from "@aws-cdk/aws-lambda";

export class OrderServiceInfraStack extends cdk.Stack {
    constructor(scope: cdk.Construct, id: string, props?: cdk.StackProps) {
        super(scope, id, props);

        new Function(this, "order-service-function", null); //compilation error
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Few quick observations - </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>We have imported Function class from @aws-cdk/aws-lambda</li><li>Constructor of Function class takes 3 parameters -<ul><li>scope: Construct - which identifies the parent resource</li><li>id: string - unique identifier of the resource within the stack</li><li>props: FunctionProps - lambda function properties including name, runtime, handler etc</li></ul></li><li>Typescript compiler gives an error because null is not acceptable in place of FunctionProps</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Let's pass the required function properties - </p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {Code, Function, FunctionProps, Runtime} from "@aws-cdk/aws-lambda";
import {Construct, Stack, StackProps} from "@aws-cdk/core";

export class OrderServiceInfraStack extends Stack {
    constructor(scope: Construct, id: string, props?: StackProps) {
        super(scope, id, props);

        //create FunctionProps
        const functionProperties: FunctionProps = {
            code: Code.fromAsset("../dist"),
            handler: "handler.ordersHandler",
            runtime: Runtime.NODEJS_10_X,
            functionName: "order-service-function",
            environment: {"ExecutionEnvironment": "dev"}
        };
        new Function(this, "order-service-function", functionProperties);
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Here, <em>code, handler and runtime</em> are the only mandatory properties. Passing them should make the compiler happy. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>With this change in OrderServiceInfraStack, our test will break because it asserts for empty resources inside the stack but now stack contains a lambda function. We will fix the test in a moment.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Quick observation - </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>We are passing <code>ExecutionEnvironment</code> as lambda environment variable. This variable is used to determine if the lambda is running is running in test mode or production mode. This value can also be taken as deployment parameter, but for now we are passing it as dev</li><li>We have used <code>../dist </code>inside code asset which contains our transpiled code</li></ul>
<!-- /wp:list -->

<!-- wp:heading {"level":4} -->
<h4>Step 3: Fixing the test</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>CDK allows us to write different forms of tests including snapshot tests and fine grained unit tests. We will be writing both the tests - snapshot test(s) for our entire stack and unit tests for resources like lambda function, dynamodb, api gateway etc.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We will be starting with unit tests which will assert on resources and their properties.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {OrderServiceInfraStack} from "../lib/OrderServiceInfraStack";
import {App} from "@aws-cdk/core";
import {Runtime} from "@aws-cdk/aws-lambda";
import "@aws-cdk/assert/jest";

test("stack should contain a lambda function with node10 as the runtime", () => {
    const app = new App();
    const stack = new OrderServiceInfraStack(app, "OrderServiceStack");

    expect(stack).toHaveResource("AWS::Lambda::Function", {
        Runtime: Runtime.NODEJS_10_X.toString()
    })
});</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Few quick observations - </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>We have imported <code>aws-cdk/assert/jest</code> which provides us with <code>expect</code> function that allows us to match resources in the stack</li><li>Our unit test asserts only on lambda's runtime property</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>That's it. Our lambda function resource is created in the stack and we have been able to write a unit test. Let's commit the changes.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Step 4: Adding DynamoDB to stack</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's provision dynamodb. In order to do so we need to add a dependency <code>@aws-cdk/aws-dynamodb</code>. So, let's add it by executing <code>npm install @aws-cdk/aws-dynamodb@1.19.0</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {Code, Function, FunctionProps, Runtime} from "@aws-cdk/aws-lambda";
import {Construct, Stack, StackProps} from "@aws-cdk/core";
import {AttributeType, Table, TableProps} from "@aws-cdk/aws-dynamodb";

export class OrderServiceInfraStack extends Stack {
    constructor(scope: Construct, id: string, props?: StackProps) {
        super(scope, id, props);

        //create FunctionProps
        const functionProperties: FunctionProps = {
            code: Code.fromAsset("../dist"),
            handler: "handler.ordersHandler",
            runtime: Runtime.NODEJS_10_X,
            functionName: "order-service-function",
            environment: {"ExecutionEnvironment": "dev"}
        };
        new Function(this, "order-service-function", functionProperties);

        //create TableProps
        const tableProps: TableProps = {
            partitionKey: {
                name: "orderId",
                type: AttributeType.STRING
            },
            tableName: "orders"
        };
        new Table(this, "order-table", tableProps);
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Few quick observations - </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>We have imported Table class from @aws-cdk/aws-dynamodb</li><li>Constructor of Table class takes 3 parameters -<ul><li>scope: Construct - which identifies the parent resource</li><li>id: string - unique identifier of the resource within the stack</li><li>props: TableProps - table properties including name of the table, partitionKey etc</li></ul></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>That's it. Our dynamo table resource is created in the stack. Let's verify by writing a unit test.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>test("stack should contain a dynamodb table with table name", () => {
    const app = new App();
    const stack = new OrderServiceInfraStack(app, "OrderServiceStack");

    expect(stack).toHaveResource("AWS::DynamoDB::Table", {
        "TableName": "orders"
    })
});

test("stack should contain a dynamodb table with orderId as the Hash key", () => {
    const app = new App();
    const stack = new OrderServiceInfraStack(app, "OrderServiceStack");

    expect(stack).toHaveResource("AWS::DynamoDB::Table", {
        "KeySchema": [
            {
                "AttributeName": "orderId",
                "KeyType": "HASH"
            }
        ]
    })
});</code></pre>
<!-- /wp:code -->

<!-- wp:heading {"level":4} -->
<h4>Step 5: Refactoring the stack</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's look at a unit test and see if there are any challenges in understanding it. </p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>test("stack should contain a lambda function with node10 as runtime", () => {
    const app = new App();
    const stack = new OrderServiceInfraStack(app, "OrderServiceStack");

    expect(stack).toHaveResource("AWS::Lambda::Function", {
        Runtime: Runtime.NODEJS_10_X.toString()
    })
});</code></pre>
<!-- /wp:code -->

<!-- wp:list {"ordered":true} -->
<ol><li>How do you know our stack will contain a lambda function with node10 as the runtime? Honestly, there is no relation between the test input and its output</li><li>Even though the test is for OrderServiceStack, I see that we are trying to assert on properties of a resource. It somehow looks to me like a misplaced test</li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>In order to solve both the problems, we can create a component (or a class) which will take some properties and create a lambda function. This means we will be able to move lambda function unit tests closer to that class and make the unit tests more revealing. Let's see how. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's consider that all our lambda functions are based on node10 runtime. With this consideration, we can create a class <code>Node10LambdaFunction</code> which represents a lambda function and accepts properties that are relevant to our project defined by <code>Node10LambdaFunctionProperties</code>. </p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {Code, Function, FunctionProps, Runtime} from "@aws-cdk/aws-lambda";
import {Construct} from "@aws-cdk/core";

//inherit from Function
export class Node10LambdaFunction extends Function {
    constructor(scope: Construct, properties: Node10FunctionProperties) {
        super(scope, properties.functionName, properties.toFunctionProps())
    }
}

class Node10LambdaFunctionProperties {
    //attributes that make sense at this stage
    constructor(private readonly code: Code,
                private readonly handler: string,
                readonly functionName: string,
                private readonly environmentVariables?: { &#91;key: string]: string }) {
    }

    //return FunctionProps
    toFunctionProps(): FunctionProps {
        return {
            code: this.code,
            handler: this.handler,
            runtime: Runtime.NODEJS_10_X,
            functionName: this.functionName,
            environment: this.environmentVariables
        }
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Few quick observations - </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Client of Node10LambdaFunction (which is going be our stack now) is not required to pass runtime as it is evident from the name itself</li><li>Client code is not required to pass id of the resource. Node10LambdaFunction passes function name as the id of the resource</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Now, we can move the lambda function unit tests closer to <code>Node10LambdaFunction</code>. This is how the updated test(s) will look like -</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>test("stack should contain a lambda function with node10 as runtime", () => {
    const stack = new Stack();
    const properties = new Node10LambdaFunctionProperties(
        Code.fromAsset("../dist"),
        "handler.ordersHandler",
        "order-service-function");

    new Node10LambdaFunction(stack, properties);

    expect(stack).toHaveResource("AWS::Lambda::Function", {
        Runtime: Runtime.NODEJS_10_X.toString()
    })
});

test("stack should contain a lambda function with specified environment variable", () => {
    const stack = new Stack();
    const properties = new Node10LambdaFunctionProperties(
        Code.fromAsset("../dist"),
        "handler.ordersHandler",
        "order-service-function",
        {"env": "dev"});

    new Node10LambdaFunction(stack, properties);

    expect(stack).toHaveResource("AWS::Lambda::Function", {
        Environment: {
            Variables: {
                "env": "dev"
            }
        }
    })
});</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Here, we are not instantiating OrderServiceStack but creating an empty stack which gets passed to Node10LambdaFunction. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Similarly, we can write other tests around lambda function like - assert that lambda function is created with a given name, assert that lambda function is inside a VPC etc. I will make similar changes for Dynamo table and commit the code.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>With these changes, we can write unit tests for various components (as fine grained as we want) and a snapshot test for the entire stack.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Step 6: Adding lambda backed public RestApi to stack</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's provision a rest api. In order to do so we need to add a dependency <code>@aws-cdk/aws-apigateway</code>. So, let's add it by executing <code>npm install @aws-cdk/aws-apigateway@1.19.0</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Following the same pattern we would like to create a class that allows us to add an endpoint which can be accessed publicly and is backed by a lambda function.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {LambdaRestApi, LambdaRestApiProps, MethodLoggingLevel} from "@aws-cdk/aws-apigateway";
import {Construct} from "@aws-cdk/core";
import {Node10LambdaFunction} from "../../function/Node10LambdaFunction";
import {IFunction} from "@aws-cdk/aws-lambda";

//inherit from LambdaRestApi
class LambdaBackedPublicRestApi extends LambdaRestApi {

    constructor(scope: Construct, properties: LambdaBackedPublicRestApiProperties) {
        super(scope, properties.apiName, properties.toLambdaRestApiProps());
    }
}

class LambdaBackedPublicRestApiProperties {

    constructor(readonly apiName: string,
                private readonly stageName: string,
                private handler: Node10LambdaFunction) {
    }

    //return LambdaRestApiProps
    toLambdaRestApiProps(): LambdaRestApiProps {
        return {
            restApiName: this.apiName,
            deployOptions: {
                stageName: this.stageName,
                loggingLevel: MethodLoggingLevel.INFO
            },
            proxy: false,
            handler: this.handler as IFunction
        }
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>This will create a RestApi in the stack for us but there is no endpoint available for us. In order to allow that to happen we can expose a method that takes a resource path say - "<code>order/{orderId}</code>" and an http method which needs to be attached to the last part of resource which in this example is <code>{orderId}</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>So, let's do this.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {
    LambdaRestApi,
    LambdaRestApiProps,
    MethodLoggingLevel,
    Resource
} from "@aws-cdk/aws-apigateway";
import {Construct} from "@aws-cdk/core";
import {Node10LambdaFunction} from "../../function/Node10LambdaFunction";
import {IFunction} from "@aws-cdk/aws-lambda";

class LambdaBackedPublicRestApi extends LambdaRestApi {

    constructor(scope: Construct, properties: LambdaBackedPublicRestApiProperties) {
        super(scope, properties.apiName, properties.toLambdaRestApiProps());
    }

    //add resource say, orders/{orderId} and a method GET against {orderId}
    addEndpoint(resourcePath: string, httpMethod: HttpMethod) {
        if (resourcePath.startsWith("/"))
            throw new IllegalArgumentException(
                `${resourcePath} should not begin with a / while adding a rest endpoint`
            );

        const resource = this.addAllResourcesUsing(resourcePath);
        resource.addMethod(httpMethod);
    }

    //add resources recursively
    private addAllResourcesUsing(resourcePath: string): Resource {
        function add(resources: string&#91;], rootResource: Resource): Resource {
            if (resources.length === 0)
                return rootResource;
            else
                return add(
                    resources.slice(1, resources.length),
                    LambdaBackedPublicRestApi.getOrAdd(resources&#91;0], rootResource)
                );
        }

        return add(resourcePath.split("/"), (this.root as Resource));
    }

    private static getOrAdd(resourcePath: string, rootResource: Resource): Resource {
        const alreadyPresentResource = rootResource.getResource(resourcePath) as Resource;
        return alreadyPresentResource || rootResource.addResource(resourcePath)
    }
}

class LambdaBackedPublicRestApiProperties {

    constructor(readonly apiName: string,
                private readonly stageName: string,
                private handler: Node10LambdaFunction) {
    }

    toLambdaRestApiProps(): LambdaRestApiProps {
        return {
            restApiName: this.apiName,
            deployOptions: {
                stageName: this.stageName,
                loggingLevel: MethodLoggingLevel.INFO
            },
            proxy: false,
            handler: this.handler as IFunction
        }
    }
}

enum HttpMethod {
    GET = "GET"
}

class IllegalArgumentException extends Error {
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Few quick observations - </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>We do not expect the resource path to begin with a "/", <code>aws-apigateway</code> throws an error if that is the case</li><li>We are recursively adding each resource from the resource path</li><li>Http method gets added on the last resource of the resource path</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Let's quickly add some unit tests.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {LambdaBackedPublicRestApi} from "../../../lib/restapi/public/LambdaBackedPublicRestApi";
import {Stack} from "@aws-cdk/core";
import {LambdaBackedPublicRestApiProperties} from "../../../lib/restapi/public/LambdaBackedPublicRestApiProperties";
import {Node10LambdaFunctionProperties} from "../../../lib/function/Node10LambdaFunctionProperties";
import {Code} from "@aws-cdk/aws-lambda";
import {Node10LambdaFunction} from "../../../lib/function/Node10LambdaFunction";
import "@aws-cdk/assert/jest";
import {HttpMethod} from "../../../lib/restapi/public/HttpMethod";
import {CfnMethod} from "@aws-cdk/aws-apigateway";

const addFakeEndpoint = (api: LambdaBackedPublicRestApi) => {
    api.addEndpoint("fake", HttpMethod.GET);
};

test("stack should contain a public api with a name", () => {
    const stack = new Stack();
    const node10LambdaFunction = new Node10LambdaFunction(
        stack,
        new Node10LambdaFunctionProperties(
            Code.fromAsset("../dist"),
            "handler.ordersHandler",
            "order-service-function"));

    const properties = new LambdaBackedPublicRestApiProperties(
        "orders-api",
        "dev",
        node10LambdaFunction
    );

    const api = new LambdaBackedPublicRestApi(stack, properties);
    addFakeEndpoint(api);

    expect(stack).toHaveResource("AWS::ApiGateway::RestApi", {
        Name: "orders-api"
    });
});

test("stack should contain a public api with stage name", () => {
    const stack = new Stack();
    const node10LambdaFunction = new Node10LambdaFunction(
        stack,
        new Node10LambdaFunctionProperties(
            Code.fromAsset("../dist"),
            "handler.ordersHandler",
            "order-service-function"));

    const properties = new LambdaBackedPublicRestApiProperties(
        "orders-api",
        "dev",
        node10LambdaFunction
    );

    const api = new LambdaBackedPublicRestApi(stack, properties);
    addFakeEndpoint(api);

    expect(stack).toHaveResource("AWS::ApiGateway::Stage", {
        StageName: "dev"
    });
});

test("stack should contain a public api with a resource", () => {
    const stack = new Stack();
    const node10LambdaFunction = new Node10LambdaFunction(
        stack,
        new Node10LambdaFunctionProperties(
            Code.fromAsset("../dist"),
            "handler.ordersHandler",
            "order-service-function"));

    const properties = new LambdaBackedPublicRestApiProperties(
        "orders-api",
        "dev",
        node10LambdaFunction
    );

    const api = new LambdaBackedPublicRestApi(stack, properties);
    api.addEndpoint("article/serverless", HttpMethod.GET);

    //assert a resource
    const articleResource = api.root.getResource("article");
    expect(articleResource).toBeDefined();

    const serverlessResource = articleResource?.getResource("serverless");
    expect(serverlessResource).toBeDefined();
});

test("stack should contain a public api with an http method added to the resource", () => {
    const stack = new Stack();
    const node10LambdaFunction = new Node10LambdaFunction(
        stack,
        new Node10LambdaFunctionProperties(
            Code.fromAsset("../dist"),
            "handler.ordersHandler",
            "order-service-function"));

    const properties = new LambdaBackedPublicRestApiProperties(
        "orders-api",
        "dev",
        node10LambdaFunction
    );

    const api = new LambdaBackedPublicRestApi(stack, properties);
    api.addEndpoint("article/serverless", HttpMethod.GET);

    //get a resource and a CfnMethod against that resource
    const serverlessResource = api.root.getResource("article")?.getResource("serverless");
    const method = serverlessResource?.node.findChild("GET") as CfnMethod;

    expect(method.httpMethod).toEqual(HttpMethod.GET);
});</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><em>These tests assert that a rest api exists with a given name, with a given stage name, with a resource and an http method attached to a resource.</em></p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Step 7: Updating the stack</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Let's update the stack to have lambda function, dynamo table, lambda backed public api and dynamo table read access to lambda function.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {Code} from "@aws-cdk/aws-lambda";
import {Construct, Stack, StackProps} from "@aws-cdk/core";
import {AttributeType} from "@aws-cdk/aws-dynamodb";
import {Node10LambdaFunction} from "./function/Node10LambdaFunction";
import {Node10LambdaFunctionProperties} from "./function/Node10LambdaFunctionProperties";
import {DynamoTable} from "./dynamodb/DynamoTable";
import {DynamoTableProperties} from "./dynamodb/DynamoTableProperties";
import {PrimaryKey} from "./dynamodb/PrimaryKey";
import {PartitionKey} from "./dynamodb/PartitionKey";
import {LambdaBackedPublicRestApi} from "./restapi/public/LambdaBackedPublicRestApi";
import {LambdaBackedPublicRestApiProperties} from "./restapi/public/LambdaBackedPublicRestApiProperties";
import {HttpMethod} from "./restapi/public/HttpMethod";

export class OrderServiceInfraStack extends Stack {
    constructor(scope: Construct, id: string, props?: StackProps) {
        super(scope, id, props);

        //use the newly prepared classes
        const ordersFunction = this.ordersFunction();
        const ordersTable    = this.ordersTable();
        const restApi        = this.lambdaBackedPublicRestApi(ordersFunction);

        restApi.addEndpoint("orders/{orderId}", HttpMethod.GET);
        ordersTable.grantReadData(ordersFunction);
    }

    private ordersFunction() {
        return new Node10LambdaFunction(this, new Node10LambdaFunctionProperties(
            Code.fromAsset("../dist"),
            "handler.ordersHandler",
            "order-service-function",
            {"ExecutionEnvironment": "dev"})
        );
    }

    private ordersTable() {
        return new DynamoTable(this, new DynamoTableProperties(
            "orders",
            new PrimaryKey(
                new PartitionKey(
                    "orderId",
                    AttributeType.STRING)
            ))
        );
    }

    private lambdaBackedPublicRestApi(lambda: Node10LambdaFunction) {
        return new LambdaBackedPublicRestApi(this, new LambdaBackedPublicRestApiProperties(
            "orders-api",
            "dev",
            lambda
        ));
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Time to add our snapshot test, probably simpler than you might have thought of -</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {OrderServiceInfraStack} from "../lib/OrderServiceInfraStack";
import {App} from "@aws-cdk/core";
import "@aws-cdk/assert/jest";

test("should create order service stack", () => {
    const app = new App();
    const stack = new OrderServiceInfraStack(app, "OrderServiceStack");

    expect(stack).toMatchSnapshot();
});</code></pre>
<!-- /wp:code -->

<!-- wp:heading {"level":4} -->
<h4>Step 8: Deploying our stack</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We have worked hard to create all the resources that are needed in our stack. Now is the time to deploy our stack and see things in action.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's update <code>OrderServiceInfra</code> to pass stack name as a part of stack properties. It is this file which acts as an entry point for the application and is referred in cdk.json.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#!/usr/bin/env node
import "source-map-support/register";
import {OrderServiceInfraStack} from "../lib/OrderServiceInfraStack";
import {StackProps} from "@aws-cdk/core";
import cdk = require("@aws-cdk/core");

const app = new cdk.App();
//pass stack name
const stackProps:StackProps = {
    stackName: "order-service-stack"
};
new OrderServiceInfraStack(app, "OrderServiceStack", stackProps);</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>CDK also provides us with various commands - </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li><code>cdk list</code> - lists the stacks</li><li><code>cdk deploy</code> - deploys the stack in AWS environment</li><li><code>cdk destroy</code> - destroys the stacks</li><li><code>cdk synthesize</code> - synthesizes and prints the CloudFormation</li><li><code>cdk bootstrap</code> - deploys the CDK toolkit stack into an AWS environment</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>We need to execute <code>cdk bootrap</code> and <code>cdk deploy</code> from <code>infra</code> directory to deploy stack in our AWS account.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>> cd infra
> cdk bootstrap
> cdk deploy</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>These commands make a few assumptions -</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>AWS credentials are already configured on host machine</li><li>AWS user has the right to create various AWS resources including IAM roles</li><li><code>dist/</code> directory which will be deployed on an S3 bucket (bootstrap creates for us) when we execute <code>cdk bootstrap</code>, already exists </li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>It will take sometime for stack to be created which will consist of <code>lambda function, dynamo table, api gateway and all the necessary IAM roles</code>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Once our stack is created, make an entry in <code>orders</code> table, hit the public api endpoint which will look like <em><code>https://rest-api-id.execute-api.ap-south-1.amazonaws.com/dev/orders/OrderId</code></em> and enjoy the output. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>That's it, our stack is deployed and our application is up and running 😁</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Conclusion </h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>Relationship between CDK and CloudFormation can be summarised as -</p>
<!-- /wp:paragraph -->

<!-- wp:image {"align":"center","id":1043,"width":511,"height":252,"sizeSlug":"large","className":"is-style-default"} -->
<div class="wp-block-image is-style-default"><figure class="aligncenter size-large is-resized"><img src="https://tech-lessons.in/wp-content/uploads/2020/03/CDK.png" alt="" class="wp-image-1043" width="511" height="252"/></figure></div>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>In this article we were able to code our infra using CDK, write tests for our infra and deploy the same. Let's take a look at some of the advantages of using <a href="https://docs.aws.amazon.com/cdk/latest/guide/home.html">CDK</a> - </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Resources can be modeled in Object Oriented manner</li><li>High level abstractions can be defined and published within the team or company</li><li>Infrastructure can be built as library</li><li>Infrastructure code can be tested</li><li>IDE's code completion can be leveraged</li><li>Programming language constructs like if statements, for-loops, etc can be used when defining infrastructure</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>We have finally come to end of our Serverless Journey series. Hope you enjoyed it.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>790</wp:post_id>
		<wp:post_date><![CDATA[2020-03-17 07:58:34]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="aws-lambda"><![CDATA[AWS Lambda]]></category>
		<category domain="category" nicename="serverless"><![CDATA[Serverless]]></category>
		<category domain="post_tag" nicename="serverless"><![CDATA[Serverless]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[classic-editor-remember]]></wp:meta_key>
		<wp:meta_value><![CDATA[block-editor]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[inherit]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[29]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[CDK]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[59]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_cd749b0941a67ed22edd12c53f04c768]]></wp:meta_key>
		<wp:meta_value><![CDATA[<iframe title="AWS CDK" width="500" height="281" src="https://www.youtube.com/embed/W8sibGJnHEM?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_time_cd749b0941a67ed22edd12c53f04c768]]></wp:meta_key>
		<wp:meta_value><![CDATA[1584352275]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[30]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Testing Serverless Journey</title>
		<link>http://tech-lessons.in/?p=955</link>
		<pubDate></pubDate>
		<dc:creator><![CDATA[sarthakmakhija]]></dc:creator>
		<guid isPermaLink="false">http://tech-lessons.in/?p=955</guid>
		<description></description>
		<content:encoded><![CDATA[<!-- wp:paragraph -->
<p>It is time to test our <a href="https://tech-lessons.in/beginning-serverless-journey">Serverless journey</a> which started with a web application that involved AWS lambda, AWS API Gateway and AWS DynamoDB. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>We had some unit tests for our controller, service and request objects. But, these tests don't give us the kind of confidence we need to deploy our application. At this stage we don't even know if the query that is written in repository is going to work properly or not, forget about releasing the application.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>What we need is an ability to test the following - </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Repository works as expected by connecting to DynamoDB</li><li>Lambda handler is able to receive an event from API Gateway and get an order by its id</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>In simple terms we need some form of integration testing. </p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Let's welcome LocalStack</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>LocalStack<a href="https://github.com/localstack/localstack"> </a>is a fully functional local AWS cloud stack. Its <a href="https://github.com/localstack/localstack">github</a> page states the following - </p>
<!-- /wp:paragraph -->

<!-- wp:quote -->
<blockquote class="wp-block-quote"><p><em>LocalStack</em>&nbsp;provides an easy-to-use test/mocking framework for developing Cloud applications. Currently, the focus is primarily on supporting the AWS cloud stack.  </p></blockquote>
<!-- /wp:quote -->

<!-- wp:paragraph -->
<p>LocalStack spins up various Cloud APIs on local machine including S3, Lambda, DynamoDB and API Gateway. This is all we need to test our complete application. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Some of you might be having a question "Why is S3 needed?". Well, we will get an answer to this by the end of this article. So, please hold on.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Understanding LocalStack</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>LocalStack can be made to run as a docker container on a host machine. It supports quite a number of AWS services which will run inside the docker container with different ports exposed on host machine. </p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Before moving on let's look at this conversation to understand how can LocalStack be leveraged for testing Serverless application. </p>
<!-- /wp:paragraph -->

<!-- wp:core-embed/youtube {"url":"https://youtu.be/Xed6C8vskUo","type":"video","providerNameSlug":"youtube","align":"center","className":"wp-embed-aspect-16-9 wp-has-aspect-ratio"} -->
<figure class="wp-block-embed-youtube aligncenter wp-block-embed is-type-video is-provider-youtube wp-embed-aspect-16-9 wp-has-aspect-ratio"><div class="wp-block-embed__wrapper">
https://youtu.be/Xed6C8vskUo
</div></figure>
<!-- /wp:core-embed/youtube -->

<!-- wp:paragraph -->
<p>Let's take some small steps to test our application using LocalStack.</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Writing Repository Test</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>In order to test repository layer we need to -</p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li>Build the project</li><li>Have a docker container with a running DynamoDB service</li><li>Facilitate creation of "orders" table in DynamoDB service</li><li>Change the application to connect to local DynamoDB service</li><li>Add integration tests for repository</li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Let's handle each of them one by one.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Step 1: Build the project</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's add a build task to our outer package.json which will execute <code>tsc</code>. Let's also add a types definition for node by executing <code>npm i @types/node</code>. Here, is how our build script looks like - </p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>"scripts": {
  "test": "jest test/**",
  "build": "tsc"
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Before we execute our build command, let's <code>exclude infra and test</code> folders from our outer tsconfig.json.</p>
<!-- /wp:paragraph -->

<!-- wp:preformatted -->
<pre class="wp-block-preformatted">{
  "compilerOptions": {
    "noEmitOnError": true,
    "moduleResolution": "node",
    "module": "commonjs",
    "target": "es6",
    "outDir": "dist",
    "inlineSourceMap": true
  },
  "exclude": ["infra", "test"]
}</pre>
<!-- /wp:preformatted -->

<!-- wp:paragraph -->
<p>Now, we can execute <code>npm run build</code> which should produce a <code>dist</code> folder with compiled code.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><em>Note we are using tsc to transpile our typescript code to javascript. We do not have any external dependencies to be packed with our distribution, had there been any we would have gone ahead with webpack.</em></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Step 2: Docker container with a running DynamoDB service</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's create a docker-compose file referring to LocalStack image and start the container as a pretest step in our package.json.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>version: "2.1"
services:
  localstack:
    image: localstack/localstack:0.10.7
    ports:
      - "4567-4599:4567-4599"
      - "${PORT_WEB_UI-8080}:${PORT_WEB_UI-8080}"
    environment:
      - SERVICES=${SERVICES- }
      - DEBUG=1
      - DATA_DIR=${DATA_DIR- }
      - PORT_WEB_UI=${PORT_WEB_UI- }
      - LAMBDA_EXECUTOR=${LAMBDA_EXECUTOR- }
    volumes:
      - "/var/run/docker.sock:/var/run/docker.sock"</code></pre>
<!-- /wp:code -->

<!-- wp:code -->
<pre class="wp-block-code"><code>  "scripts": {
    "pretest": "docker-compose -f test/docker-compose.yml up -d",
    "test": "jest test/**",
    "build": "tsc"
  }</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Run the pretest command and see LocalStack running as docker container.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Step 3: Facilitate creation of "orders" table in DynamoDB service</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>With LocalStack container up and running, "orders" table needs to be created in DynamoDB service. In order to do this we will use CloudFormation template. So, let's write one -</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>AWSTemplateFormatVersion: "2010-09-09"
Resources:
  OrdersTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: "orders"
      AttributeDefinitions:
        - AttributeName: "orderId"
          AttributeType: "S"
      KeySchema:
        - AttributeName: "orderId"
          KeyType: "HASH"</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>We will also create a script to deploy CloudFormation template against LocalStack. This script will also be executed as a part of our pretest step.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#!/bin/sh

aws cloudformation deploy \
--template-file template.yaml \
--stack-name order-service-stack \
--region us-east-1 \
--capabilities CAPABILITY_IAM  \
--endpoint-url http://localhost:4581

echo 'aws cloudformation deploy executed against localstack'</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Few Quick Observations - </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>As a part of "<code>aws cloudformation deploy</code>", us-east-1 has been specified as the region. By default, LocalStack runs with us-east-1 and we are using the same region</li><li>As a part of "<code>aws cloudformation deploy</code>", local CloudFormation service endpoint exposed by LocalStack has been specified by using <code>--endpoint-url</code></li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Let's update our package.json.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>  "scripts": {
    "localstack:up": "docker-compose -f test/docker-compose.yml up -d",
    "delay": "sleep 20",
    "localstack:create-infra": "cd test/infra &amp;&amp; ./deploy.sh",
    "pretest": "npm run localstack:up &amp;&amp; npm run delay &amp;&amp; npm run localstack:create-infra",
    "test": "jest test/**",
    "build": "tsc"
  }</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Following events happens as a part of pretest step -</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>LocalStack docker container starts</li><li>Some delay gets introduced</li><li>CloudFormation template gets deployed against LocalStack</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Before CloudFormation template can be deployed on LocalStack, a small delay has been specified to ensure LocalStack with its services is up and running.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>How do I know if "orders" table was created?</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>LocalStack <em>tries</em> to replicate AWS services on local. By this theory, we should be able to run AWS commands by specifying the endpoint-url of the corresponding service.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>> aws dynamodb scan --table-name orders --endpoint-url http://localhost:4569

##Output##
{
    "Count": 0,
    "Items": [],
    "ScannedCount": 0,
    "ConsumedCapacity": null
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Now, the last step is making a change in the application to connect to local DynamoDB.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Step 4: Connecting the application to local DynamoDB service</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's change the repository layer to connect to local DynamoDB service.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {GetItemInput} from "aws-sdk/clients/dynamodb";
import {Order} from "../model/Order";
import {dynamoDbClient} from "../DynamoDbConfiguration";

const dynamoDb = dynamoDbClient(); //get dynamoDbClient from DynamoDbConfiguration

export class OrderRepository {

    async findAnOrderBy(id: string) {
        const getItemInputOptions: GetItemInput = {
            TableName: "orders",
            Key: {
                "orderId": {S: id}
            }
        };
        const response = await dynamoDb.getItem(getItemInputOptions).promise();
        return response.Item ? Order.from(response.Item) : null;
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>DynamoDbConfiguration looks like - </p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {DynamoDB} from "aws-sdk"

const executionEnvironment = () => {
    const defaultExecutionEnvironment = "test";
    return process.env.ExecutionEnvironment || defaultExecutionEnvironment;
};

const isTestExecutionEnvironment = () => executionEnvironment() === "test";

export const dynamoDbClient = () => {
    if (isTestExecutionEnvironment()) {
        return new DynamoDB({
            "region": "us-east-1",
            "endpoint": "http://localhost:4569"
        });
    } else {
        return new DynamoDB({
            "region": "ap-south-1"
        });
    }
};</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Few Quick Observations - </p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>OrderRepository uses <code>dynamoDbClient</code> exposed by DynamoDbConfiguration <code>globally</code>. The reason being "aws-sdk" needs to be initialised during cold startup of lambda function</li><li>DynamoDbConfiguration uses a lambda environment variable to determine if the execution environment is "test". By default, execution environment is considered as "test"</li><li>If execution environment is "test", then an instance of DynamoDB connecting to local dynamo service is returned</li><li>This also means ExecutionEnvironment needs to be passed during deployment as lambda environment variable</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p><strong>Step 5: Adding Integration Tests for Repository</strong></p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {DeleteItemInput, PutItemInput} from "aws-sdk/clients/dynamodb";

import {OrderRepository} from "../src/repository/OrderRepository";
import {Order}           from "../src/model/Order";
import {dynamoDbClient}  from "../src/DynamoDbConfiguration";

const dynamoDb = dynamoDbClient();

test("should return an order given there is AN order for the provided order id", async () => {
    const orderId = "order-100";
    
    await OrderRepositoryFixture.deleteAnOrder(orderId);
    await OrderRepositoryFixture.createAn(new Order(orderId, 5000));
    
    const order = await new OrderRepository().findAnOrderBy(orderId);

    expect(order.orderId).toEqual(orderId);
    expect(order.amount).toEqual(5000);
});

test("should NOT return an order given there is NO order for the provided order id", async () => {
    const orderId = "no-order-present-for-this-order-id";
    const order = await new OrderRepository().findAnOrderBy(orderId);

    expect(order).toBeNull();
});

class OrderRepositoryFixture {
    static async createAn(order: Order) {
        const item: PutItemInput = {
            TableName: "orders",
            Item: {
                "orderId": {
                    S: order.orderId
                },
                "amount": {
                    N: order.amount.toString()
                }
            }
        };
        await dynamoDb.putItem(item).promise()
    }
    static async deleteAnOrder(orderId: string) {
        const item: DeleteItemInput = {
            TableName: "orders",
            Key: {
                "orderId": {
                    S: orderId
                }
            }
        };
        await dynamoDb.deleteItem(item).promise();
    }
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>That's it run all the tests <code>npm t</code> and see them pass 😁</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Connecting the dots</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We have been able test our repository against DynamoDB service running in LocalStack. What we want to do next is - </p>
<!-- /wp:paragraph -->

<!-- wp:list {"ordered":true} -->
<ol><li>Deploy lambda function code against lambda function service in LocalStack</li><li>Create Rest Api backed by lambda function in LocalStack</li><li>Adding integration tests to send an http request against the Api Gateway</li></ol>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>Let's start.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Step 6: Deploy lambda function code</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In order to deploy the lambda function code, we need to build the code, archive it, upload the archive on S3 service running inside LocalStack and update CloudFormation template to create the lambda function by referring to the S3 bucket.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's archive the code, create an S3 bucket and upload the archive on S3 service.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>"scripts": {
    "localstack:down": "docker-compose -f test/docker-compose.yml down",
    "localstack:up": "docker-compose -f test/docker-compose.yml up -d",
    "delay": "sleep 20",
    "localstack:create-infra": "cd test/infra &amp;&amp; ./init.sh",
    "archive": "cd dist/ &amp;&amp; zip -r ../serverless-order-service.zip .",
    "pretest": "npm run build &amp;&amp; npm run archive &amp;&amp; npm run localstack:down &amp;&amp; npm run localstack:up &amp;&amp; npm run delay &amp;&amp; npm run localstack:create-infra",
    "test": "jest test/**",
    "build": "tsc"
  }</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Following events happens as a part of pretest step –</p>
<!-- /wp:paragraph -->

<!-- wp:list -->
<ul><li>Code gets built</li><li>Distribution gets archived</li><li>LocalStack docker container gets stopped</li><li>LocalStack docker container starts</li><li>Some delay gets introduced</li><li>CloudFormation template gets deployed against LocalStack</li></ul>
<!-- /wp:list -->

<!-- wp:paragraph -->
<p>package.json now runs <code>build</code> and <code>archive</code> as a part of <code>pretest</code> step. <code>archive</code> simply creates a zip file which is ready to uploaded on an S3 bucket. localstack:create-infra now runs init.sh which delegates the job of creating a bucket, uploading the archive and deploying the infra to different scripts.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Let's see the commands to create an S3 bucket and upload the archive -</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>> aws s3 mb s3://serverless-order-service --endpoint-url http://localhost:4572

> aws s3 cp ../../serverless-order-service.zip \
s3://serverless-order-service --endpoint-url http://localhost:4572</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Let's update CloudFormation template to create lambda resource.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>AWSTemplateFormatVersion: "2010-09-09"
Resources:
  OrdersFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: "order-service-function"
      Runtime: "nodejs10.x"
      Handler: "handler.ordersHandler"
      Code:
        S3Bucket: "serverless-order-service"   //created earlier
        S3Key: "serverless-order-service.zip"  //uploaded earlier
      Role: !GetAtt "OrdersRole.Arn"           //refer to a dummy role created below

  OrdersRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: "OrdersFunctionRole"
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Action:
              - "sts:AssumeRole"
            Principal:
              Service:
                - "lambda.amazonaws.com"

  OrdersTable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: "orders"
      AttributeDefinitions:
        - AttributeName: "orderId"
          AttributeType: "S"
      KeySchema:
        - AttributeName: "orderId"
          KeyType: "HASH"</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Executing <code>npm t</code> should create AWS lambda function in LocalStack. We can verify the same -</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>>  aws lambda list-functions --endpoint-url http://localhost:4574/

##Output
{
    "FunctionArn": "arn:aws:lambda:us-east-1:000000000000:function:order-service-function", 
    "Handler": "handler.ordersHandler", 
    "Role": "test_role", 
    "Timeout": 3, 
    "Runtime": "nodejs10.x"
}</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Let's move on to creating a Rest Api.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p><strong>Step 7: Create Rest Api </strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This should be simple, let's update our CloudFormation template to have a Rest Api with <code>/orders/{instanceId}</code> as the resource and a <code>GET</code> method.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>AWSTemplateFormatVersion: "2010-09-09"
Resources: 
  ## Content Trimmed

  OrdersApiGateway:
    Type: AWS::ApiGateway::RestApi
    Properties:
      Name: "orders-api"

  OrdersResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !GetAtt "OrdersApiGateway.RootResourceId"
      PathPart: "orders"
      RestApiId: !Ref "OrdersApiGateway"

  OrderIdResource:
    Type: AWS::ApiGateway::Resource
    Properties:
      ParentId: !Ref "OrdersResource"
      PathPart: "{orderId}"
      RestApiId: !Ref "OrdersApiGateway"

  OrdersGetMethod:
    Type: AWS::ApiGateway::Method
    Properties:
      HttpMethod: "GET"
      AuthorizationType: "NONE"
      RestApiId: !Ref "OrdersApiGateway"
      ResourceId: !Ref "OrderIdResource"
      Integration:
        IntegrationHttpMethod: "POST"
        Type: "AWS_PROXY"
        Uri:
          Fn::Join:
            - ""
            - - "arn:"
              - "aws"
              - ":apigateway:"
              - Ref: AWS::Region
              - :lambda:path/2015-03-31/functions/
              - Fn::GetAtt:
                  - OrdersFunction
                  - Arn
              - /invocations</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Executing <code>npm t</code> should create Rest Api in LocalStack. We can verify the same -</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>> aws apigateway get-rest-apis \
--query "items[?name=='orders-api'].id" \
--output text --region us-east-1 \
--endpoint-url=http://localhost:4567

##Should print Api Id</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p><strong>Step 8: Adding Integration Test for the application</strong></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>In order to write this integration test we should be sending an http request to an endpoint exposed by Api Gateway inside LocalStack. This endpoint with LocalStack looks like -<br><em>http://localhost:4567/restapis/&lt;&lt;Rest Api Id&gt;&gt;/test/_user_request_/orders/&lt;&lt;Order Id&gt;&gt;</em></p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>This means we need a way to get the rest api id that was created as a part of deployment of CloudFormation template. We will add <code>aws apigateway get-rest-apis</code> command as a part of a script which will be executed from <code>init.sh</code>. This command will write the rest api id into a file which will be read by our integration test.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#!/bin/sh

aws apigateway get-rest-apis \
--query "items[?name=='orders-api'].id" \
--output text --region us-east-1 \
--endpoint-url=http://localhost:4567 > rest_api_id</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>This is how our init.sh looks now -</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>#!/bin/sh

./createBucket.sh
./package.sh
./deploy.sh
./outputRestApiId.sh</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Now, it is the time to add integration test.</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {OrderRepositoryFixture} from "./fixture/OrderRepositoryFixture";
import {Order} from "../src/model/Order";

import * as fs from "fs";
import * as path from "path";
import Axios from "axios"

let apiId = "";

beforeEach(() => {
    //read rest api id
    apiId = fs.readFileSync(path.resolve("test/infra/rest_api_id"), "utf8").trim();
});

test("should return an order given there is AN order for the provided order id", async () => {

    const orderId = "order-500";

    await OrderRepositoryFixture.deleteAnOrder(orderId);
    await OrderRepositoryFixture.createAn(new Order(orderId, 4000));

    const apiUrl = `http://localhost:4567/restapis/${apiId}/test/_user_request_/orders/${orderId}`;
    const response = await Axios.get(apiUrl);

    expect(response.status).toEqual(200);
    expect(response.data).toEqual({
        "orderId": orderId,
        "amount": 4000
    });
}, 20000);</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>Before the test can be run, we will have to make one change in <code>DynamoDbConfiguration</code>. It returns a <em>dynamoDbClient</em> which connects to dynamodb running on <code>localhost:4569</code>. This is not true anymore because lambda is running inside a docker container and for that lambda function "localhost:4569" will refer to the port 4569 on docker's IP. What we need is the port 4569 with the IP of host machine. So, let's make this change. This is how updated DynamoDbConfiguration will look like -</p>
<!-- /wp:paragraph -->

<!-- wp:code -->
<pre class="wp-block-code"><code>import {DynamoDB} from "aws-sdk"

const executionEnvironment = () => {
    const defaultExecutionEnvironment = "local";
    return process.env.ExecutionEnvironment || defaultExecutionEnvironment;
};

const isExecutionEnvironmentLocal = () => executionEnvironment() === "local";

export const dynamoDbClient = () => {
    if (isExecutionEnvironmentLocal()) {
        /** LOCALSTACK_HOSTNAME: 
        *     for accessing the hostname from inside the container
        *   localhost: 
        *     for running repository integration tests which run on host machine
        **/ 
        const dynamoHost = process.env.LOCALSTACK_HOSTNAME || "localhost";
        return new DynamoDB({
            "region": "us-east-1",
            "endpoint":`http://${dynamoHost}:4569`
        });
    } else {
        return new DynamoDB({
            "region": "ap-south-1"
        });
    }
};</code></pre>
<!-- /wp:code -->

<!-- wp:paragraph -->
<p>LocalStack exposes an environment variable LOCALSTACK_HOSTNAME which is available inside docker process that refers to the host machine.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>That's it run all the tests <code>npm t</code> and see them pass 😁</p>
<!-- /wp:paragraph -->

<!-- wp:heading {"level":4} -->
<h4>Summary</h4>
<!-- /wp:heading -->

<!-- wp:paragraph -->
<p>We used LocalStack to test our application. Everything is available <a href="https://github.com/aws-articles/serverless-order-service.git">here</a>.</p>
<!-- /wp:paragraph -->

<!-- wp:paragraph -->
<p>Here is a quick glimpse of the sequence of events that happen when tests are executed.</p>
<!-- /wp:paragraph -->

<!-- wp:image {"id":1030,"sizeSlug":"large","className":"is-style-default"} -->
<figure class="wp-block-image size-large is-style-default"><img src="https://tech-lessons.in/wp-content/uploads/2020/03/Serverless-LocalStack-1.png" alt="" class="wp-image-1030"/></figure>
<!-- /wp:image -->

<!-- wp:paragraph -->
<p>Let's move on to our last <a href="https://tech-lessons.in/concluding-serverless-journey">article</a> and see everything in action on AWS account.</p>
<!-- /wp:paragraph -->]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>955</wp:post_id>
		<wp:post_date><![CDATA[2020-03-17 07:59:39]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[0000-00-00 00:00:00]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[]]></wp:post_name>
		<wp:status><![CDATA[draft]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="aws-lambda"><![CDATA[AWS Lambda]]></category>
		<category domain="category" nicename="serverless"><![CDATA[Serverless]]></category>
		<category domain="post_tag" nicename="serverless"><![CDATA[Serverless]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[classic-editor-remember]]></wp:meta_key>
		<wp:meta_value><![CDATA[block-editor]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[inherit]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[29]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[30]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_a8add9ca41c91952f6c5fc768c15be18]]></wp:meta_key>
		<wp:meta_value><![CDATA[<iframe title="Serverless testing localstack" width="500" height="281" src="https://www.youtube.com/embed/Xed6C8vskUo?feature=oembed" frameborder="0" allow="accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture" allowfullscreen></iframe>]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_oembed_time_a8add9ca41c91952f6c5fc768c15be18]]></wp:meta_key>
		<wp:meta_value><![CDATA[1584270237]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[968]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[LocalStack]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[21]]></wp:meta_value>
		</wp:postmeta>
							</item>
				</channel>
</rss>
	