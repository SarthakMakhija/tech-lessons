<?xml version="1.0" encoding="UTF-8" ?>
<!-- This is a WordPress eXtended RSS file generated by WordPress as an export of your site. -->
<!-- It contains information about your site's posts, pages, comments, categories, and other content. -->
<!-- You may use this file to transfer that content from one site to another. -->
<!-- This file is not intended to serve as a complete backup of your site. -->

<!-- To import this information into a WordPress site follow these steps: -->
<!-- 1. Log in to that site as an administrator. -->
<!-- 2. Go to Tools: Import in the WordPress admin panel. -->
<!-- 3. Install the "WordPress" importer from the list. -->
<!-- 4. Activate & Run Importer. -->
<!-- 5. Upload this file using the form provided on that page. -->
<!-- 6. You will first be asked to map the authors in this export file to users -->
<!--    on the site. For each author, you may choose to map to an -->
<!--    existing user on the site or to create a new user. -->
<!-- 7. WordPress will then import each of the posts, pages, comments, categories, etc. -->
<!--    contained in this file into your site. -->

	<!-- generator="WordPress/5.3.2" created="2020-03-26 15:06" -->
<rss version="2.0"
	xmlns:excerpt="http://wordpress.org/export/1.2/excerpt/"
	xmlns:content="http://purl.org/rss/1.0/modules/content/"
	xmlns:wfw="http://wellformedweb.org/CommentAPI/"
	xmlns:dc="http://purl.org/dc/elements/1.1/"
	xmlns:wp="http://wordpress.org/export/1.2/"
>

<channel>
	<title>tech-lessons.in</title>
	<link>http://tech-lessons.in</link>
	<description>tech lessons and learnings from a developer</description>
	<pubDate>Thu, 26 Mar 2020 15:06:49 +0000</pubDate>
	<language>en-US</language>
	<wp:wxr_version>1.2</wp:wxr_version>
	<wp:base_site_url>http://tech-lessons.in</wp:base_site_url>
	<wp:base_blog_url>http://tech-lessons.in</wp:base_blog_url>

		<wp:author><wp:author_id>1</wp:author_id><wp:author_login><![CDATA[sarthakmakhija]]></wp:author_login><wp:author_email><![CDATA[sarthak.makhija@gmail.com]]></wp:author_email><wp:author_display_name><![CDATA[sarthakmakhija]]></wp:author_display_name><wp:author_first_name><![CDATA[]]></wp:author_first_name><wp:author_last_name><![CDATA[]]></wp:author_last_name></wp:author>

		<wp:category>
		<wp:term_id>16</wp:term_id>
		<wp:category_nicename><![CDATA[kotlin]]></wp:category_nicename>
		<wp:category_parent><![CDATA[]]></wp:category_parent>
		<wp:cat_name><![CDATA[Kotlin]]></wp:cat_name>
<wp:category_description><![CDATA[Kotlin is a statically typed JVM language and all posts under Kotlin talk about some of the features in Kotlin]]></wp:category_description>
	</wp:category>
				
	<generator>https://wordpress.org/?v=5.3.2</generator>

		<item>
		<title>Kotlin Wishlist for Java</title>
		<link>http://tech-lessons.in/kotlin-wishlist-for-java/</link>
		<pubDate>Mon, 30 Apr 2018 10:50:36 +0000</pubDate>
		<dc:creator><![CDATA[sarthakmakhija]]></dc:creator>
		<guid isPermaLink="false">http://tech-lessons.in/?p=131</guid>
		<description></description>
		<content:encoded><![CDATA[There is no doubt that Java has enjoyed a superior position when it comes to programming languages and is considered as one of the most important languages for development. However, there have been a number of languages developed on top of the JVM, like <a href="https://kotlinlang.org/" target="_blank" rel="nofollow noopener noreferrer">Kotlin</a>.

Kotlin is a statically typed programming language for modern multi-platform applications. While I have been a Java developer for quite a long while, working on a project <a href="https://github.com/dataanon/data-anon" target="_blank" rel="nofollow noopener noreferrer">data-anonymization</a> made me feel that there are things that Java should consider importing from Kotlin.

These are some of the Kotlin features that I would love to see making a place in Java.
<h3>Promote Immutability</h3>
Java 9 promotes immutability by introducing factory methods to create collections. It would be great to see immutable collections embedded in the language, rather than relying on wrappers to generate immutable collections. <em>existingDepartments()</em> is a function that returns an immutable list of Strings in Kotlin.
<pre class="lang:default decode:true ">//Kotlin
fun existingDepartments(): List =
    listOf("Human Resources", "Learning &amp;amp; Development", "Research")</pre>
Java 9 comes closest to returning an immutable list by throwing an UnsupportedOperationException when an attempt is made to add or remove an element from the list. It would be great to have a separate hierarchy of mutable and immutable collections and avoid exposing add/remove or any other mutating methods from immutable collections.
<pre class="lang:java decode:true ">//pre Java 8
public List existingDepartments() {
    return new ArrayList(){{
        add("Human Resources");
        add("Learning &amp;amp; Development");
        add("Research");
    }};
}
//Java 8
public List existingDepartments() {
    return Stream.of("Human Resources", "Learning &amp;amp; Development", "Research")
                 .collect(Collectors.toList());
}
//Java 9
public List existingDepartments() {
    return List.of("Human Resources", 
                   "Learning &amp;amp; Development", 
                   "Research");
}</pre>
<blockquote>Being more explicit about immutable collections and letting immutable collections speak out loud for themselves should be given preference over exposing methods and throwing UnsupportedOperationExceptions</blockquote>
<h3>Method Parameters Should Be Final by Default</h3>
With an intent to promote immutability and avoid errors because of mutation, it might be worth to at least giving a thought to making method parameters final by default.
<pre class="lang:default decode:true ">//Kotlin
fun add (augend: Int, addend: Int) = augend + addend</pre>
Parameters for the <em>add() </em>function are val by default cannot be changed, which means as a client of any function, I can rest assured that the function is not changing the arguments (<em>not to be confused with object mutation</em>) that are passed to it.
<blockquote>Making method parameters final by default might and will most likely break existing code bases on Java upgrades but is worth giving a thought</blockquote>
<h3>Handle NULL at Compile Time</h3>
Every Java developer is bound to know the infamous NullPointerException. Kotlin took a major step by handling NULLs at compile time. Everything is non-null be default until it is explicitly stated.

Did Java 8 not introduce Optional for the very same reason ? Let's see with an example:
<pre class="lang:default decode:true ">//Kotlin
class Employee(private val id: Int, private val department: Department?) {
    fun departmentName() = department?.name ?: "Unassigned"
}
class Department(val name: String)
/**
    Employee needs a non-nullable "id" and an optional department to be constructed.
    val employee = Employee(null, null); &lt;b&gt; Compile Time Error &lt;/b&gt;
**/</pre>
The<em> Employee</em> class has a primary constructor with a <em>non-nullable id and an optional (nullable) department</em>. Passing null for the id will result in a compile time error.

The <em>departmentName() </em>function accesses the name property of Department using the optional operator <strong>?</strong> on the nullable field. If department is null, name will not be accessed and the expression on the left-hand side <em>[department?.name]</em> will return null. The <em>Elvis operator </em><strong>?:</strong> will return the right hand side (<em>"Unassigned"</em>) if the left-hand side of the expression is null.
<pre class="lang:default decode:true ">//Java 8
class Employee {
    private Integer id;
    private Optional department
    Employee(Integer id, Optional department){
       this.id = id;
       this.department = department;
    }
    public String departmentName() {
       return department.orElse("Unassigned");
    }
}
/**
    Employee needs a non-nullable "id" and an optional department to be constructed.
    Employee employee = new Employee(null, null); &lt;b&gt;NPE !!!&lt;/b&gt;
**/</pre>
Optional will not protect the code from NPE, but Optional has its advantages:
<ul>
 	<li>It makes the domain model clear. The <em>Employee</em> class has an optional department, which is good enough to conclude that every employee may not be assigned a department</li>
 	<li>It promotes composability as in the <em>departmentName()</em> method</li>
</ul>
<blockquote>Handling NULLs at compile time should result in cleaner code by removing unnecessary NULL checks in the form of an if statement, Objects.requireNonNull, Preconditions.checkNotNull, any other form</blockquote>
To keep things simple, department was passed in to the constructor even though this is an optional attribute.
<h3>Improve Lambdas</h3>
Java 8 introduced lambdas, which are built on top of a functional interface and a functional descriptor, meaning every lambda expression will map to the signature of an abstract method defined in that functional interface. This effectively means it is a mandate to have an interface (Functional Interface) with only one abstract method (Functional Descriptor) to create a lambda expression.
<pre class="lang:default decode:true ">//Kotlin
val isPositive: (Int) -&gt; Boolean = { it &gt; 0 }
OR,
val isPositive: (Int) -&gt; Boolean = { num &gt; 0 }
OR,
val isPositive: (Int) -&gt; Boolean = { num: Int &gt; 0 }

//Usage
isPositive(10) returns true
isPositive(-1) returns false</pre>
Above, the variable<em> isPositive </em>is <em>a function</em> that takes an Int as an argument and returns a Boolean. The value of this variable is a function definition or a lambda defined in braces, which checks that the passed argument is greater than zero.

Whereas, as seen in Java below, <em>Predicate</em> is a functional interface containing an abstract method <em>test()</em> — which takes an argument of type T and returns a boolean.

So, <em>isPositive</em> takes an argument of type Integer and checks that it is greater than zero. In order to use it, we need to invoke the <em>test()</em> method on <em>isPositive</em>.
<pre class="lang:default decode:true ">//Java 8
private Predicate&lt;Integer&gt; isPositive = (Integer arg) -&gt; arg &gt; 0;

//Usage
isPositive.test(10) returns true
isPositive.test(-1) returns false

@FunctionalInterface
public interface Predicate&lt;T&gt; {
    boolean test(T t);
}</pre>
<blockquote>Lambdas should be independent of functional interfaces and their functional descriptors</blockquote>
<h3>Support Extension Functions</h3>
Kotlin supports extension functions, which provide the ability to extend a class with new functionality without having to inherit from the class or use any type of design pattern, such as Decorator.

Let's write an extension function to return the last character of a String, meaning <em>"Kotin".lastChar() will return 'n'.</em>
<pre class="lang:default decode:true ">//Kotlin
fun String.lastChar() = this.toCharArray()[this.length - 1]
/**
    Extension functions are of the form -
    fun &lt;ReceiverObject&gt;.function_name() = body
    OR,
    fun &lt;ReceiverObject&gt;.function_name(arg1: Type1, ... argN: TypeN) = body
**/</pre>
Here, <em>lastChar()</em> is an extension function defined on String, which is called a receiver object. This function can now be invoked as <em>"Kotlin".lastChar().</em>
<blockquote>Extension functions provide an ability to extend a class with new functionalities without inheritance or any other design pattern</blockquote>
<h3>Tail Recursion</h3>
Kotlin provides support for <a href="https://kotlinlang.org/docs/reference/functions.html" target="_blank" rel="nofollow noopener noreferrer">Tail-recursion</a>. Tail-recursion is a form of recursion in which the recursive calls are the last instructions in the function (tail). In this way, we don't care about previous values, and one stack frame suffices for all of the recursive calls; tail-recursion is one way of optimizing recursive algorithms.

The other advantage/optimization is that there is an easy way to transform a tail-recursive algorithm to an equivalent one that uses iteration instead of recursion.
<pre class="lang:default decode:true ">//Kotlin
fun factorialTco(val: Int): Int {
    tailrec fun factorial(n: Int, acc: Int): Int = 
         if ( n == 1 ) acc else factorial(n - 1, acc * n)
  return  factorial(val, acc = 1)
}</pre>
When a function is marked with the <em>tailrec</em> modifier and meets the required form, the compiler optimizes out the recursion, leaving behind a fast and efficient loop-based version instead.
<blockquote>Effectively, a tail-recursive function can execute in constant stack space, so it's really just another formulation of an iterative process</blockquote>
Java does not directly support tail-call optimization at the compiler level, but one can use <em><a href="http://blog.agiledeveloper.com/2013/01/functional-programming-in-java-is-quite.html" target="_blank" rel="nofollow noopener noreferrer">lambda expressions</a></em> to implement it. It would be nice to see TCO at the compiler level.
<h2>Miscellaneous</h2>
<ul>
 	<li><strong>Remove inherent duplication [new, return, semicolon]: </strong>Kotlin does not require <strong>new</strong> to create an instance. It still needs a <strong>return </strong>if a function is treated as a statement instead of an expression.</li>
</ul>
<pre class="lang:default decode:true ">//Kotlin
class Employee(private val id: Int, private val department: Department?) {
    //no return
    fun departmentNameWithoutReturn() = department?.name ?: "Unassigned"
    //return is needed if a function is treated as a statmentrather than an expression
    fun departmentNameWithoutReturn() {
        val departmentName = department?.name ?: "Unassigned"
        return departmentName
    }
}</pre>
<ul>
 	<li><strong>Singleton Classes</strong>: It would be great to see an easier way to create singleton classes in Java. An equivalent syntax in Kotlin is seen below.</li>
</ul>
<pre class="lang:default decode:true ">//Kotlin
object DataProviderManager {
fun registerDataProvider(provider: DataProvider) {
        // ...
    }
}</pre>
<ul>
 	<li><strong>Immutable Classes</strong>: It would be good to see something like the <strong>readonly</strong>/<strong>immutable </strong>modifier to create an immutable class. The below mentioned code snippet is simply a thought (not available in Kotlin or Java).</li>
</ul>
<pre class="lang:default decode:true ">//Hypothetical [Not available so far]
immutable class User(private val name: String, private val id: Int)</pre>
<strong>In conclusion</strong>, as developers, we will always make mistakes (skipping NULL checks, mutating a collection, etc.), but providing such features at the language level will make our lives easier and prevent mistakes.

<div>
[wp_ulike]
</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>131</wp:post_id>
		<wp:post_date><![CDATA[2018-04-30 10:50:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-04-30 10:50:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[kotlin-wishlist-for-java]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="immutability"><![CDATA[Immutability]]></category>
		<category domain="post_tag" nicename="java"><![CDATA[Java]]></category>
		<category domain="category" nicename="kotlin"><![CDATA[Kotlin]]></category>
		<category domain="post_tag" nicename="kotlin"><![CDATA[Kotlin]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[inherit]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[153]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[16]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw_text_input]]></wp:meta_key>
		<wp:meta_value><![CDATA[Kotlin Wishlist]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[Kotlin Wishlist]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[Kotlin is a statically typed JVM language and this is an attempt to describe some features that I would like to see brought to the Java language.]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[73]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[30]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_wp_old_slug]]></wp:meta_key>
		<wp:meta_value><![CDATA[a-kotlin-wishlist-for-java]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_like_ip]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:1:{i:0;s:15:"114.143.114.122";}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_like_count]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[kodex_post_likes]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[kodex_post_dislikes]]></wp:meta_key>
		<wp:meta_value><![CDATA[a:0:{}]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[kodex_post_likes_count]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[kodex_post_dislikes_count]]></wp:meta_key>
		<wp:meta_value><![CDATA[0]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_liked]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[classic-editor-remember]]></wp:meta_key>
		<wp:meta_value><![CDATA[block-editor]]></wp:meta_value>
		</wp:postmeta>
							</item>
					<item>
		<title>Kotlin DSL</title>
		<link>http://tech-lessons.in/kotlin-dsl/</link>
		<pubDate>Sun, 27 May 2018 17:29:36 +0000</pubDate>
		<dc:creator><![CDATA[sarthakmakhija]]></dc:creator>
		<guid isPermaLink="false">http://tech-lessons.in/?p=196</guid>
		<description></description>
		<content:encoded><![CDATA[<p style="text-align: left;">A domain-specific language (DSL) is a computer language specialized to a particular application domain. This is in contrast to a general-purpose language (GPL), which is broadly applicable across domains. There are a wide variety of DSLs, ranging from widely used languages for common domains, such as HTML for web pages, down to languages used by only one or a few pieces of software.</p>

<h3>Kotlin DSL</h3>
<p style="text-align: left;">Kotlin provides first class support for DSL which allows us to express domain-specific operations much more concisely than an equivalent piece of code in a general-purpose language.</p>
Let's try and build a simple DSL in Kotlin -
<pre class="lang:java decode:true" title="DSL">dependencies {
   compile("io.arrow-kt:arrow-data:0.7.1")
   compile("io.arrow-kt:arrow-instances-core:0.7.1")
   testCompile("io.kotlintest:kotlintest-runner-junit5:3.1.0")
}</pre>
<p style="text-align: left;">This should be familiar to people using <em>gradle</em> as their build tool. Above DSL specifies compile and testCompile dependencies for a gradle project in very concise and expressive form.</p>

<h3>How does Kotlin support DSL</h3>
Before we get in to Kotlin's support for DSL, let's look at lambdas in Kotlin.
<pre class="lang:java decode:true" title="Lambda in Kotlin">fun buildString(action: (StringBuilder) -&gt; Unit): String {
   val sb = StringBuilder()
   action(sb)
   return sb.toString()
}
</pre>
buildString() takes a lambda as a parameter (called action) and invokes it by passing an instance of StringBuilder. Any client code which invokes buildString() will look like the below code -
<pre class="lang:java decode:true" title="Invoking buildString">val str = buildString {
    it.append("Hello")
    it.append(" ")
    it.append("World")
}</pre>
A few things to note here -
<ul>
 	<li>buildString() takes lambda as the last parameter. If a function takes lambda as the last parameter, Kotlin allows you to invoke the function using braces { .. }, no need of using parentheses</li>
 	<li><strong>it </strong>is the implicit parameter available in lambda body which is an instance of StringBuilder in this example</li>
</ul>
This information is good enough to write a <em>gradle dependencies DSL.</em>
<h3>First Attempt at DSL</h3>
In order to build a gradle dependencies DSL we <em>need a function called dependencies</em> which should take a lambda of type T as a parameter where T provides compile and testCompile functions.

Let's try -
<pre class="lang:java decode:true">fun dependencies(action: (DependencyHandler) -&gt; Unit): DependencyHandler {
    val dependencies = DependencyHandler()
    action(dependencies)
    return dependencies
}

class DependencyHandler {
    fun compile(coordinate: String){
        //add coordinate to some collection
    }
    fun testCompile(coordinate: String){
        //add coordinate to some collection
    }
}</pre>
dependencies is a simple function which takes a lambda accepting an instance of DependencyHandler as an parameter and returning Unit. DependencyHandler is the type T which has compile and testCompile functions.

Client code for the above concept will look like -
<pre class="lang:java decode:true">dependencies {
   it.compile("") //it is an instance of DependencyHandler
   it.testCompile("")
}</pre>
Are we done? Not really. The problem is the implicit parameter <strong>it </strong>used in the client code. Can we remove <strong>it</strong>? In order to remove implicit parameter, we need to look at "Lambda With Receiver".
<h3>Lambda With Receiver</h3>
Receiver is a simple type in Kotlin which is extended.

Let's see this with an example -
<pre class="lang:default decode:true">fun String.lastChar() : Char = 
                  this.toCharArray().get(this.length - 1)</pre>
We have extended String to have lastChar() as a function which means we can always invoke it as -
<pre class="lang:default decode:true ">"Kotlin".lastChar()</pre>
<em>Here, <span style="text-decoration: underline;">String is the receiver type</span> and <span style="text-decoration: underline;">this</span> used in the body of lastChar() is the receiver object. </em>Can we combine these 2 concepts - lambda and receiver?

Let's rewrite our buildString function using lambda with receiver -
<pre class="lang:java decode:true ">fun buildString(action: StringBuilder.() -&gt; Unit): String {
    val sb = StringBuilder()
    sb.action()
    return sb.toString()
}</pre>
A few things to note here -
<ul>
 	<li>buildString() takes a lambda with receiver as an parameter</li>
 	<li>StringBuilder is the receiver type in the lambda</li>
 	<li>the way we invoke action function is different this time. Because <strong>action</strong> is an extension function on StringBuilder we invoke it using <strong>sb.action()</strong>, where sb is an instance of StringBuilder</li>
</ul>
Let's create a client of buildString function -
<pre class="lang:java decode:true">val str = buildString {
    this.append("Hello") //this here is an instance of StringBuilder
    append(" ")
    append("World")
}</pre>
Isn't this brilliant? Client code will always have access to <strong>this</strong> while invoking a function which takes <em>lambda with receiver</em> as a parameter.

Shall we rewrite our <em>gradle</em> <em>dependencies DSL</em> code?
<h3>Another Attempt at DSL</h3>
<pre class="lang:java decode:true">fun dependencies(action: DependencyHandler.() -&gt; Unit): DependencyHandler {
    val dependencies = DependencyHandler()
    dependencies.action()
    return dependencies
}

class DependencyHandler {
    fun compile(coordinate: String){
        //add coordinate to some collection
    }
    fun testCompile(coordinate: String){
        //add coordinate to some collection
    }
}</pre>
The only change we have done here is in <em>dependencies</em> function which <em>takes a lambda with receiver as the parameter</em>. <em>DependencyHandler is the receiver type</em> in <em>action</em> parameter which means the <em>client code will always have access to the instance of DependencyHandler.</em>

Let's see the client code -
<pre class="lang:java decode:true">dependencies {
   compile("")     //same as this.compile("")
   testCompile("")
}</pre>
We are  able to create a DSL using <em>Lambda with Receiver</em> as a parameter to a function.
<h3>Operator Function invoke()</h3>
Kotlin provides an interesting function called <strong>invoke</strong> which is an operator function. Specifying invoke operator on a class allows it to be called on <strong>any instances of the class without a method name</strong>.

Let's see this in action -
<pre class="lang:java decode:true ">class Greeter(val greeting: String) {
    operator fun invoke(name: String) {
        println("$greeting $name")
    }
}

fun main(args: Array&lt;String&gt;) {
    val greeter = Greeter(greeting = "Welcome")
    greeter(name = "Kotlin")  //this calls the invoke function which takes String as a parameter
}</pre>
A few things to note about <strong>invoke()</strong> here -
<ul>
 	<li>is an operator function</li>
 	<li>takes parameter</li>
 	<li>can be overloaded</li>
 	<li>is being called on the instance of Greeter class without method name</li>
</ul>
Let's use <strong>invoke</strong> in building DSL -
<h3>Building DSL using invoke function</h3>
<pre class="lang:java decode:true">class DependencyHandler {
    fun compile(coordinate: String){
        //add coordinate to some collection
    }
    fun testCompile(coordinate: String){
        //add coordinate to some collection
    }
    operator fun invoke(action: DependencyHandler.() -&gt; Unit): DependencyHandler {
        this.action()
        return this
    }
}</pre>
We have defined an <em>operator function in DependencyHandler which takes a lambda with receiver as a parameter</em>. This means <strong>invoke</strong> will automatically be called on instance(s) of DependencyHandler and client code will have access to instance of DependencyHandler.

Let's write the client code -
<pre class="lang:java decode:true">val dependencies = DependencyHandler()
dependencies { //as good as dependencies.invoke(..)
   compile("")
   testCompile("")
}</pre>
invoke() can come in handy while building DSL.
<h3>Conclusion</h3>
<ul>
 	<li>Kotlin provides a first class support for DSL which is type safe</li>
 	<li>One can create a DSL in Kotlin using -
<ul>
 	<li>Lambda as function parameters</li>
 	<li>Lambda With Receiver as function parameter</li>
 	<li>operator function invoke along with Lambda With Receiver as function parameter</li>
</ul>
</li>
</ul>
<h3>References</h3>
<ul>
 	<li>Kotlin In Action</li>
</ul>
<div>[wp_ulike]</div>]]></content:encoded>
		<excerpt:encoded><![CDATA[]]></excerpt:encoded>
		<wp:post_id>196</wp:post_id>
		<wp:post_date><![CDATA[2018-05-27 17:29:36]]></wp:post_date>
		<wp:post_date_gmt><![CDATA[2018-05-27 17:29:36]]></wp:post_date_gmt>
		<wp:comment_status><![CDATA[open]]></wp:comment_status>
		<wp:ping_status><![CDATA[open]]></wp:ping_status>
		<wp:post_name><![CDATA[kotlin-dsl]]></wp:post_name>
		<wp:status><![CDATA[publish]]></wp:status>
		<wp:post_parent>0</wp:post_parent>
		<wp:menu_order>0</wp:menu_order>
		<wp:post_type><![CDATA[post]]></wp:post_type>
		<wp:post_password><![CDATA[]]></wp:post_password>
		<wp:is_sticky>0</wp:is_sticky>
										<category domain="post_tag" nicename="domain-specific-language"><![CDATA[Domain Specific Language]]></category>
		<category domain="post_tag" nicename="dsl"><![CDATA[DSL]]></category>
		<category domain="category" nicename="kotlin"><![CDATA[Kotlin]]></category>
		<category domain="post_tag" nicename="kotlin"><![CDATA[Kotlin]]></category>
		<category domain="post_tag" nicename="lambda"><![CDATA[Lambda]]></category>
		<category domain="post_tag" nicename="lambda-with-receiver"><![CDATA[Lambda With Receiver]]></category>
						<wp:postmeta>
		<wp:meta_key><![CDATA[_edit_last]]></wp:meta_key>
		<wp:meta_value><![CDATA[1]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_content_score]]></wp:meta_key>
		<wp:meta_value><![CDATA[30]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_layout]]></wp:meta_key>
		<wp:meta_value><![CDATA[inherit]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_primary_category]]></wp:meta_key>
		<wp:meta_value><![CDATA[16]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw_text_input]]></wp:meta_key>
		<wp:meta_value><![CDATA[Kotlin DSL]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_focuskw]]></wp:meta_key>
		<wp:meta_value><![CDATA[Kotlin DSL]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_linkdex]]></wp:meta_key>
		<wp:meta_value><![CDATA[81]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_thumbnail_id]]></wp:meta_key>
		<wp:meta_value><![CDATA[224]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_yoast_wpseo_metadesc]]></wp:meta_key>
		<wp:meta_value><![CDATA[Kotlin provides first class support for DSL which allows us to express domain-specific operation much more concisely than an equivalent piece of code in a general-purpose language. Kotlin DSL is type safe and concise.]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[_liked]]></wp:meta_key>
		<wp:meta_value><![CDATA[3]]></wp:meta_value>
		</wp:postmeta>
							<wp:postmeta>
		<wp:meta_key><![CDATA[classic-editor-remember]]></wp:meta_key>
		<wp:meta_value><![CDATA[block-editor]]></wp:meta_value>
		</wp:postmeta>
							</item>
				</channel>
</rss>
	