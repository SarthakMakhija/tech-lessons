<!DOCTYPE html> <!-- Type on Strap jekyll theme v2.0.0 Copyright 2016-2019 Sylhare Theme free for personal and commercial use under the MIT license https://github.com/sylhare/Type-on-Strap/blob/master/LICENSE --> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"> <!-- CSS --> <link rel="stylesheet" href="/assets/css/main.css"> <!--Favicon--> <link rel="shortcut icon" href="/assets/favicon.png" type="image/x-icon"> <!-- Canonical --> <link rel="canonical" href="https://tech-lessons.in/bloom-filter/"> <!-- KaTeX 0.8.3 --> <!-- if you have any issue check https://github.com/KaTeX/KaTeX --> <!-- Google Analytics --> <!-- End Google Analytics --> <!-- seo tags --> <!-- Begin Jekyll SEO tag v2.8.0 --> <title>Bloom filter | tech-lessons.in</title> <meta name="generator" content="Jekyll v4.3.2" /> <meta property="og:title" content="Bloom filter" /> <meta name="author" content="Sarthak Makhija" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="A Bloom filter is a probabilistic data structure used to test whether an element is a set member. A bloom filter can query against large amounts of data and return either “possibly in the set” or “definitely not in the set”." /> <meta property="og:description" content="A Bloom filter is a probabilistic data structure used to test whether an element is a set member. A bloom filter can query against large amounts of data and return either “possibly in the set” or “definitely not in the set”." /> <link rel="canonical" href="https://tech-lessons.in/bloom-filter/" /> <meta property="og:url" content="https://tech-lessons.in/bloom-filter/" /> <meta property="og:site_name" content="tech-lessons.in" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2023-02-25T00:00:00+05:30" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Bloom filter" /> <script type="application/ld+json"> {"@context":"https://schema.org","@type":"BlogPosting","author":{"@type":"Person","name":"Sarthak Makhija","url":"https://github.com/sarthakmakhija"},"dateModified":"2023-02-25T00:00:00+05:30","datePublished":"2023-02-25T00:00:00+05:30","description":"A Bloom filter is a probabilistic data structure used to test whether an element is a set member. A bloom filter can query against large amounts of data and return either “possibly in the set” or “definitely not in the set”.","headline":"Bloom filter","mainEntityOfPage":{"@type":"WebPage","@id":"https://tech-lessons.in/bloom-filter/"},"url":"https://tech-lessons.in/bloom-filter/"}</script> <!-- End Jekyll SEO tag --> <!-- Manual seo tags --> <!-- <title>Bloom filter | tech-lessons.in</title> <meta name="description" content="A Bloom filter is a probabilistic data structure used to test whether an element is a set member. A bloom filter can query against large amounts of data and ..."> --> </head> <script defer=true src="/assets/js/main.min.js"></script> <body> <header class="site-header"> <!-- Toggle menu --> <nav class="clear"> <a aria-label="pull" id="pull" class="toggle" href="#"> <i class="fa fa-bars fa-lg"></i> </a> <!-- Brand Logo --> <a class="navbar-brand" href="/"> <img src="/assets/img/pexels/logo.png" alt="tech-lessons" title="tech-lessons"> </a> <!-- Menu --> <ul class="hide"> <li class="separator"> |</li> <li> <a class="clear" aria-label="Home" title="Home" href="/"> <i class="fa fa-fw fa-home" aria-hidden="true"></i> Home </a> </li> <li class="separator"> |</li> <li> <a class="clear" aria-label="Search" title="Search" href="/search/"> <i class="fa fa-fw fa-search" aria-hidden="true"></i> Search </a> </li> <li class="separator"> |</li> <li> <a class="clear" aria-label="Tags" title="Tags" href="/tags/"> <i class="fa fa-fw fa-tags" aria-hidden="true"></i> Tags </a> </li> <li class="separator"> |</li> <li> <a class="clear" aria-label="About Me" title="About Me" href="/about/"> <i class="fa fa-fw fa-male" aria-hidden="true"></i> About Me </a> </li> </ul> </nav> </header> <div class="content"> <meta property="og:url" content="/bloom-filter/" /> <meta property="og:type" content="article" /> <meta property="og:title" content="Bloom filter" /> <meta property="og:description" content="A Bloom filter is a probabilistic data structure used to test whether an element is a set member. A bloom filter can query against large amounts of data and return either &quot;possibly in the set&quot; or &quot;definitely not in the set&quot;." /> <meta property="og:image" content="assets/img/pexels/bloomfilter_title.png" /> <article class="feature-image"> <header id="main" style=""></header> <section class="post-content"> <h1 id="Bloom+filter" class="title">Bloom filter</h1> <p>A Bloom filter is a probabilistic data structure<sup id="fnref:1" role="doc-noteref"><a href="#fn:1" class="footnote" rel="footnote">1</a></sup> used to test whether an element is a set member. A bloom filter can query against large amounts of data and return either “possibly in the set” or “definitely not in the set”.</p> <p>A bloom filter can have false positives, but false negatives are impossible.</p> <p>Elements can only be added to the set, <em>but not removed</em> (though this can be addressed with the counting bloom filter variant).</p> <p>Burton Howard Bloom conceived the Bloom filter in 1970.</p> <h3 id="a-basic-filter">A basic filter</h3> <p>Let’s build a basic filter for a giant persistent dictionary of lowercase English words. Here are some requirements for this filter:</p> <ol> <li>It should not take more than 26 bytes of memory</li> <li>It should return either <strong>possibly in the set</strong> or <strong>definitely not in the set</strong></li> <li>Our application will query the filter first, and only if the filter returns “possibly in the set” will the application query the persistent dictionary</li> </ol> <p>One idea to design such a filter would be to maintain a <code class="language-plaintext highlighter-rouge">boolean</code> array of size 26 (26 lowercase English letters) to <strong>indicate the presence</strong> of a word beginning with a character.</p> <p>The filter does not store the actual word; it only indicates the presence of a word. The word gets added to the persistent dictionary after adding it to the basic filter. To do that, we set the value at the <em>array index corresponding to the first letter</em> to <code class="language-plaintext highlighter-rouge">true</code>.</p> <p>To check if the dictionary contains a word, the application queries the filter first. The filter checks the value at the <em>index corresponding to the first letter</em> [<code class="language-plaintext highlighter-rouge">firstLetterOfTheWord-asciiCodeOf('a')</code>] and returns <code class="language-plaintext highlighter-rouge">true</code> if the value at the index is set, <code class="language-plaintext highlighter-rouge">false</code> otherwise.</p> <p>Let’s understand the returned values from the filter:</p> <ul> <li>If the returned value is <code class="language-plaintext highlighter-rouge">false</code>, we can conclude that the word is not present in the persistent dictionary</li> <li>If the returned value is <code class="language-plaintext highlighter-rouge">true</code>, we can not be sure if the word is present because there may be multiple words starting with the same letter</li> </ul> <p>The idea behind the basic filter is presented in the image below.</p> <div class="align-center"> <img style="padding-left: 0; max-width: 90%" src="/assets/img/pexels/basicfilter.png" class="wp-image-878" /> </div> <p>The image above also highlights a false positive case for the word “fact”.</p> <h3 id="understanding-bloom-filter">Understanding bloom filter</h3> <p>We should extend the idea of the basic filter to build a bloom filter. There are two main issues with our basic filter:</p> <ol> <li>The <code class="language-plaintext highlighter-rouge">boolean</code> array of size 26 is too small. There are billions of words in English, and an array of size 26 will cause too many false positives</li> <li>We use a single hash function to determine the array position to set or read. This hash function is <code class="language-plaintext highlighter-rouge">firstLetterOfTheWord-asciiCodeOf('a')</code></li> </ol> <p>The solution to both these problems takes us closer to the bloom filter. The bloom filter uses two main concepts:</p> <ol> <li>M-sized bit vector</li> <li>K hash functions</li> </ol> <p>The bloom filter maintains a bit array of size <code class="language-plaintext highlighter-rouge">M</code>; every key goes through <code class="language-plaintext highlighter-rouge">K</code> hash functions to determine the bit position to set.</p> <blockquote> <p><code class="language-plaintext highlighter-rouge">M</code> and <code class="language-plaintext highlighter-rouge">K</code> need to be computed.</p> </blockquote> <p>Bloom filter supports two operations:</p> <ol> <li><code class="language-plaintext highlighter-rouge">put</code> that puts a key in the bloom filter</li> <li><code class="language-plaintext highlighter-rouge">has</code> that returns either <strong>possibly in the bloom filter</strong> or <strong>definitely not in the bloom filter</strong></li> </ol> <p>Let’s summarize the working of the <code class="language-plaintext highlighter-rouge">put</code> operation. To put a key in the bloom filter, the following steps are performed:</p> <ol> <li>The input key goes through K hash functions.</li> <li>The output of every hash function is reduced to a value between <code class="language-plaintext highlighter-rouge">0 and M-1</code> to set the appropriate bit in the bit vector.</li> <li>The corresponding bit is set in the bit vector.</li> </ol> <p>Every input goes through <code class="language-plaintext highlighter-rouge">K</code> hash functions, setting at most <code class="language-plaintext highlighter-rouge">K</code> bits in the bit vector.</p> <p>The idea behind the <code class="language-plaintext highlighter-rouge">put</code> operation is presented in the image below. In the below image, we have K=2 (total hash functions) and M=8 (bit vector size).</p> <div class="align-center"> <img style="padding-left: 0; max-width: 90%" src="/assets/img/pexels/bloomfilterput.png" class="wp-image-878" /> </div> <blockquote> <p>Remember, a bloom filter does not store the actual key; it only indicates the presence of a key by using at most K bits in an M-sized bit vector.</p> </blockquote> <p>Let’s summarize the working of the <code class="language-plaintext highlighter-rouge">has</code> operation. To determine if a key <strong>maybe</strong> present in the bloom filter, the following steps need to be performed:</p> <ol> <li>The input key goes through K hash functions.</li> <li>The output of every hash function is reduced to a value between <code class="language-plaintext highlighter-rouge">0 and M-1</code> to get the appropriate bit in the bit vector.</li> <li>The corresponding bit is checked to see if it is set. If the bit is not set, we return <code class="language-plaintext highlighter-rouge">false</code>.</li> <li>We return <code class="language-plaintext highlighter-rouge">true</code> if all the bits determined from steps 1 and 2 are set.</li> </ol> <p>The idea behind the <code class="language-plaintext highlighter-rouge">has</code> operation is presented in the image below. We are using the same bit vector that was generated after the <code class="language-plaintext highlighter-rouge">put</code> operations were done. In the below image, we have K=2 (total hash functions) and M=8 (bit vector size).</p> <div class="align-center"> <img style="padding-left: 0; max-width: 90%" src="/assets/img/pexels/bloomfilterhas.png" class="wp-image-878" /> </div> <p>Bloom filters can have false positives. The image above represents a false positive for the input <code class="language-plaintext highlighter-rouge">Z</code>.</p> <h3 id="adding-tests-for-put-and-has">Adding tests for put and has</h3> <p>Let’s add a couple of tests for <code class="language-plaintext highlighter-rouge">put</code> and <code class="language-plaintext highlighter-rouge">has</code> and understand them.</p> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">TestAddsAKeyAndChecksForItsPositiveExistence</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bloomFilter</span> <span class="o">:=</span> <span class="n">newBloomFilter</span><span class="p">(</span><span class="m">20</span><span class="p">,</span> <span class="m">0.001</span><span class="p">)</span> <span class="c">//takes capacity and false positive rate</span>
    
    <span class="n">key</span> <span class="o">:=</span> <span class="n">model</span><span class="o">.</span><span class="n">NewSlice</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"Company"</span><span class="p">))</span>
    <span class="n">bloomFilter</span><span class="o">.</span><span class="n">Put</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">bloomFilter</span><span class="o">.</span><span class="n">Has</span><span class="p">(</span><span class="n">key</span><span class="p">)</span> <span class="o">==</span> <span class="no">false</span> <span class="p">{</span>
        <span class="n">t</span><span class="o">.</span><span class="n">Fatalf</span><span class="p">(</span><span class="s">"Expected %v key to be present but was not"</span><span class="p">,</span> <span class="n">key</span><span class="o">.</span><span class="n">AsString</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>As a part of this test, we do the following:</p> <ol> <li>Create a new bloom filter with <code class="language-plaintext highlighter-rouge">capacity=20</code> and <code class="language-plaintext highlighter-rouge">falsePositiveRate=0.001</code></li> <li>Create a new key of type <code class="language-plaintext highlighter-rouge">model.Slice</code>. Keys are represented by <code class="language-plaintext highlighter-rouge">Slice</code> abstraction, which is a wrapper over a byte slice.</li> <li>Put the key in.</li> <li>Assert that the key is present in the bloom filter</li> </ol> <blockquote> <p>A bloom filter can never have false negatives. So, we can be sure that the above assertion will always succeed.</p> </blockquote> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">TestAddsAKeyAndChecksForTheExistenceOfANonExistingKey</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">bloomFilter</span> <span class="o">:=</span> <span class="n">newBloomFilter</span><span class="p">(</span><span class="m">20</span><span class="p">,</span> <span class="m">0.001</span><span class="p">)</span> <span class="c">//takes capacity and false positive rate</span>
    
    <span class="n">key</span> <span class="o">:=</span> <span class="n">model</span><span class="o">.</span><span class="n">NewSlice</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"Company"</span><span class="p">))</span>
    <span class="n">bloomFilter</span><span class="o">.</span><span class="n">Put</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    
    <span class="k">if</span> <span class="n">bloomFilter</span><span class="o">.</span><span class="n">Has</span><span class="p">(</span><span class="n">model</span><span class="o">.</span><span class="n">NewSlice</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"Missing"</span><span class="p">)))</span> <span class="o">==</span> <span class="no">true</span> <span class="p">{</span>
        <span class="n">t</span><span class="o">.</span><span class="n">Fatalf</span><span class="p">(</span><span class="s">"Expected %v key to be missing but was present"</span><span class="p">,</span> <span class="n">model</span><span class="o">.</span><span class="n">NewSlice</span><span class="p">([]</span><span class="kt">byte</span><span class="p">(</span><span class="s">"Missing"</span><span class="p">))</span><span class="o">.</span><span class="n">AsString</span><span class="p">())</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>This test is very much similar to the previous one. As a part of this test, we want to assert that the given key should not be present in the bloom filter.</p> <blockquote> <p>A test of this nature can fail in the case of a false positive.</p> </blockquote> <p>Now is the right time to build a bloom filter.</p> <h3 id="building-bloom-filter">Building bloom filter</h3> <p>Let’s understand the structure of <code class="language-plaintext highlighter-rouge">BloomFilter</code> before we get into the functions.</p> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">type</span> <span class="n">BloomFilter</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">capacity</span>              <span class="kt">int</span>
    <span class="n">numberOfHashFunctions</span> <span class="kt">int</span>
    <span class="n">falsePositiveRate</span>     <span class="kt">float64</span>
    <span class="n">bitVector</span>             <span class="o">*</span><span class="n">bitset</span><span class="o">.</span><span class="n">BitSet</span>
    <span class="n">bitVectorSize</span>         <span class="kt">uint</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">newBloomFilter</span><span class="p">(</span><span class="n">capacity</span> <span class="kt">int</span><span class="p">,</span> <span class="n">falsePositiveRate</span> <span class="kt">float64</span><span class="p">)</span> <span class="o">*</span><span class="n">BloomFilter</span> <span class="p">{</span>
   
    <span class="c">//determine the number of hash functions</span>
    <span class="n">numberOfHashFunctions</span> <span class="o">:=</span> <span class="n">numberOfHashFunctions</span><span class="p">(</span><span class="n">falsePositiveRate</span><span class="p">)</span>
    
    <span class="c">//determine the bit vector size</span>
    <span class="n">bitVectorSize</span> <span class="o">:=</span> <span class="n">bitVectorSize</span><span class="p">(</span><span class="n">capacity</span><span class="p">,</span> <span class="n">falsePositiveRate</span><span class="p">)</span>
    
    <span class="c">//create a new instance of BloomFilter with a bit vector of determined size</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">BloomFilter</span><span class="p">{</span>
        <span class="n">capacity</span><span class="o">:</span>              <span class="n">capacity</span><span class="p">,</span>
        <span class="n">numberOfHashFunctions</span><span class="o">:</span> <span class="n">numberOfHashFunctions</span><span class="p">,</span>
        <span class="n">falsePositiveRate</span><span class="o">:</span>     <span class="n">falsePositiveRate</span><span class="p">,</span>
        <span class="n">bitVector</span><span class="o">:</span>             <span class="n">bitset</span><span class="o">.</span><span class="n">New</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">bitVectorSize</span><span class="p">)),</span>
        <span class="n">bitVectorSize</span><span class="o">:</span>         <span class="kt">uint</span><span class="p">(</span><span class="n">bitVectorSize</span><span class="p">),</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div> <p>The idea behind <code class="language-plaintext highlighter-rouge">newBloomFilter</code> function can be summarized as:</p> <ol> <li>Determine the number of hash functions (K)</li> <li>Determine the bit vector size (M)</li> <li>Create a new instance of <code class="language-plaintext highlighter-rouge">BitSet</code> using <code class="language-plaintext highlighter-rouge">bitset.New(...).</code></li> <li>Return a new instance of <code class="language-plaintext highlighter-rouge">BloomFilter</code></li> </ol> <blockquote> <p>The field <code class="language-plaintext highlighter-rouge">bitVector</code> inside the <code class="language-plaintext highlighter-rouge">BloomFilter</code> struct is a pointer to <code class="language-plaintext highlighter-rouge">bitset.BitSet</code>. We use the bitset package offered by the library <a href="https://github.com/bits-and-blooms/">bits-and-blooms</a>.</p> </blockquote> <p>The values of K and M are calculated using the below functions.</p> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">//calculate numberOfHashFunctions(K)</span>
<span class="k">func</span> <span class="n">numberOfHashFunctions</span><span class="p">(</span><span class="n">falsePositiveRate</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">Ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">Log2</span><span class="p">(</span><span class="m">1.0</span> <span class="o">/</span> <span class="n">falsePositiveRate</span><span class="p">)))</span>
<span class="p">}</span>

<span class="c">//calculate bitVectorSize(M)</span>
<span class="k">func</span> <span class="n">bitVectorSize</span><span class="p">(</span><span class="n">capacity</span> <span class="kt">int</span><span class="p">,</span> <span class="n">falsePositiveRate</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="c">//ln22 = ln2^2</span>
    <span class="n">ln22</span> <span class="o">:=</span> <span class="n">math</span><span class="o">.</span><span class="n">Pow</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">Ln2</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="kt">int</span><span class="p">(</span><span class="kt">float64</span><span class="p">(</span><span class="n">capacity</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">Log</span><span class="p">(</span><span class="n">falsePositiveRate</span><span class="p">))</span> <span class="o">/</span> <span class="n">ln22</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>Now that we have determined the <code class="language-plaintext highlighter-rouge">K</code> and <code class="language-plaintext highlighter-rouge">M</code> values let’s implement <code class="language-plaintext highlighter-rouge">Put</code>. The idea can be summarized as follows:</p> <ol> <li>Run <code class="language-plaintext highlighter-rouge">K</code> hash functions or a single hash function with different seed values, <code class="language-plaintext highlighter-rouge">K</code> times over an input.</li> <li>Reduce the hashed value between <code class="language-plaintext highlighter-rouge">0 and M-1</code> to set the appropriate bit in the bit vector.</li> <li>Set the bit in the bit vector at the identified position.</li> </ol> <p>This is how the above approach can be implemented:</p> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">bloomFilter</span> <span class="o">*</span><span class="n">BloomFilter</span><span class="p">)</span> <span class="n">Put</span><span class="p">(</span><span class="n">key</span> <span class="n">model</span><span class="o">.</span><span class="n">Slice</span><span class="p">)</span> <span class="p">{</span>
    <span class="c">//get the bit vector indices to set</span>
    <span class="n">indices</span> <span class="o">:=</span> <span class="n">bloomFilter</span><span class="o">.</span><span class="n">keyIndices</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">);</span> <span class="n">index</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">position</span> <span class="o">:=</span> <span class="n">indices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="c">//set the bit at the identified position</span>
        <span class="n">bloomFilter</span><span class="o">.</span><span class="n">bitVector</span><span class="o">.</span><span class="n">Set</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">position</span><span class="p">))</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="c">// Use the hash function to get all keyIndices of the given key</span>
<span class="k">func</span> <span class="p">(</span><span class="n">bloomFilter</span> <span class="o">*</span><span class="n">BloomFilter</span><span class="p">)</span> <span class="n">keyIndices</span><span class="p">(</span><span class="n">key</span> <span class="n">model</span><span class="o">.</span><span class="n">Slice</span><span class="p">)</span> <span class="p">[]</span><span class="kt">uint64</span> <span class="p">{</span>
    <span class="n">indices</span> <span class="o">:=</span> <span class="nb">make</span><span class="p">([]</span><span class="kt">uint64</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">bloomFilter</span><span class="o">.</span><span class="n">numberOfHashFunctions</span><span class="p">)</span>
    <span class="n">runHash</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">seed</span> <span class="kt">uint32</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
        <span class="n">hash</span><span class="p">,</span> <span class="n">_</span> <span class="o">:=</span> <span class="n">murmur3</span><span class="o">.</span><span class="n">Sum128WithSeed</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">seed</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">hash</span>
    <span class="p">}</span>
    <span class="n">indexForHash</span> <span class="o">:=</span> <span class="k">func</span><span class="p">(</span><span class="n">hash</span> <span class="kt">uint64</span><span class="p">)</span> <span class="kt">uint64</span> <span class="p">{</span>
        <span class="c">//index = hash % M</span>
        <span class="k">return</span> <span class="n">hash</span> <span class="o">%</span> <span class="kt">uint64</span><span class="p">(</span><span class="n">bloomFilter</span><span class="o">.</span><span class="n">bitVectorSize</span><span class="p">)</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="n">index</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="n">bloomFilter</span><span class="o">.</span><span class="n">numberOfHashFunctions</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span> <span class="p">{</span>
        <span class="c">//run murmur3 hash for the given key with index as the seed</span>
        <span class="n">hash</span> <span class="o">:=</span> <span class="n">runHash</span><span class="p">(</span><span class="n">key</span><span class="o">.</span><span class="n">GetRawContent</span><span class="p">(),</span> <span class="kt">uint32</span><span class="p">(</span><span class="n">index</span><span class="p">))</span>
        <span class="c">//identify the index between 0 and M-1 and return the indices</span>
        <span class="n">indices</span> <span class="o">=</span> <span class="nb">append</span><span class="p">(</span><span class="n">indices</span><span class="p">,</span> <span class="n">indexForHash</span><span class="p">(</span><span class="n">hash</span><span class="p">))</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">indices</span>
<span class="p">}</span>
</code></pre></div></div> <p>Let’s implement <code class="language-plaintext highlighter-rouge">Has</code>. The idea can be summarized as follows:</p> <ol> <li>Run <code class="language-plaintext highlighter-rouge">K</code> hash functions or a single hash function with different seed values, <code class="language-plaintext highlighter-rouge">K</code> times over an input.</li> <li>Reduce the hashed value between <code class="language-plaintext highlighter-rouge">0 and M-1</code> to get the appropriate bit in the bit vector.</li> <li>Check the bit in the bit vector at the identified position. If the bit is not set, return <code class="language-plaintext highlighter-rouge">false</code> to indicate that the input is absent.</li> <li>If the bits at all the identified positions are set, return <code class="language-plaintext highlighter-rouge">true</code> to indicate that the input <strong>may be present</strong>.</li> </ol> <p>This is how the above approach can be implemented:</p> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="p">(</span><span class="n">bloomFilter</span> <span class="o">*</span><span class="n">BloomFilter</span><span class="p">)</span> <span class="n">Has</span><span class="p">(</span><span class="n">key</span> <span class="n">model</span><span class="o">.</span><span class="n">Slice</span><span class="p">)</span> <span class="kt">bool</span> <span class="p">{</span>
    <span class="c">//get the bit vector indices</span>
    <span class="n">indices</span> <span class="o">:=</span> <span class="n">bloomFilter</span><span class="o">.</span><span class="n">keyIndices</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">index</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">indices</span><span class="p">);</span> <span class="n">index</span><span class="o">++</span> <span class="p">{</span>
        <span class="n">position</span> <span class="o">:=</span> <span class="n">indices</span><span class="p">[</span><span class="n">index</span><span class="p">]</span>
        <span class="c">//test the bit at the identified position, return false if the bit is not set</span>
        <span class="k">if</span> <span class="o">!</span><span class="n">bloomFilter</span><span class="o">.</span><span class="n">bitVector</span><span class="o">.</span><span class="n">Test</span><span class="p">(</span><span class="kt">uint</span><span class="p">(</span><span class="n">position</span><span class="p">))</span> <span class="p">{</span>
            <span class="k">return</span> <span class="no">false</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="no">true</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="space-optimized-data-structure">Space-optimized data structure</h3> <p>Bloom filter is a space-optimized data structure that does not store the keys. Let’s see the total space we need to hold <code class="language-plaintext highlighter-rouge">half a million keys</code> in the bloom filter.</p> <p>The values of K and M were calculated using the following functions.</p> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">//calculate numberOfHashFunctions(K)</span>
<span class="k">func</span> <span class="n">numberOfHashFunctions</span><span class="p">(</span><span class="n">falsePositiveRate</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kt">int</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">Ceil</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">Log2</span><span class="p">(</span><span class="m">1.0</span> <span class="o">/</span> <span class="n">falsePositiveRate</span><span class="p">)))</span>
<span class="p">}</span>

<span class="c">//calculate bitVectorSize(M)</span>
<span class="k">func</span> <span class="n">bitVectorSize</span><span class="p">(</span><span class="n">capacity</span> <span class="kt">int</span><span class="p">,</span> <span class="n">falsePositiveRate</span> <span class="kt">float64</span><span class="p">)</span> <span class="kt">int</span> <span class="p">{</span>
    <span class="c">//ln22 = ln2^2</span>
    <span class="n">ln22</span> <span class="o">:=</span> <span class="n">math</span><span class="o">.</span><span class="n">Pow</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">Ln2</span><span class="p">,</span> <span class="m">2</span><span class="p">)</span>
    <span class="k">return</span> <span class="kt">int</span><span class="p">(</span><span class="kt">float64</span><span class="p">(</span><span class="n">capacity</span><span class="p">)</span> <span class="o">*</span> <span class="n">math</span><span class="o">.</span><span class="n">Abs</span><span class="p">(</span><span class="n">math</span><span class="o">.</span><span class="n">Log</span><span class="p">(</span><span class="n">falsePositiveRate</span><span class="p">))</span> <span class="o">/</span> <span class="n">ln22</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>Let’s run these functions for the <code class="language-plaintext highlighter-rouge">500000</code> keys and <code class="language-plaintext highlighter-rouge">0.001</code> as the false positive rate.</p> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">func</span> <span class="n">main</span><span class="p">()</span> <span class="p">{</span>
   <span class="n">numberOfHashFunctions</span> <span class="o">:=</span> <span class="n">numberOfHashFunctions</span><span class="p">(</span><span class="m">0.001</span><span class="p">)</span>
   <span class="n">bitVectorSize</span> <span class="o">:=</span> <span class="n">bitVectorSize</span><span class="p">(</span><span class="m">500000</span><span class="p">,</span> <span class="m">0.001</span><span class="p">)</span>
   
   <span class="nb">println</span><span class="p">(</span><span class="s">"numberOfHashFunctions::"</span><span class="p">,</span> <span class="n">numberOfHashFunctions</span><span class="p">)</span>
   <span class="nb">println</span><span class="p">(</span><span class="s">"bitVectorSize::"</span><span class="p">,</span> <span class="n">bitVectorSize</span><span class="p">)</span>
<span class="p">}</span>
</code></pre></div></div> <p>The above code prints <code class="language-plaintext highlighter-rouge">numberOfHashFunctions:: 10 bitVectorSize:: 7188793</code>. This means a total space of 878KB <code class="language-plaintext highlighter-rouge">((7188793/8)/1024)</code> for storing <code class="language-plaintext highlighter-rouge">500000</code> keys.</p> <p>Now is the right time to understand how BadgerDB uses bloom filters.</p> <h3 id="badgerdb">BadgerDB</h3> <p>Bloom filter is used in a lot of projects, including <a href="https://github.com/dgraph-io/badger">BadgerDB</a> and <a href="https://github.com/apache/spark">Apache Spark</a>. This article explains the way the bloom filter is used in BadgerDB.</p> <blockquote> <p>BadgerDB is an embeddable, persistent, fast key-value (KV) database written in pure Go. Badger’s design is a combination of an LSM tree<sup id="fnref:2" role="doc-noteref"><a href="#fn:2" class="footnote" rel="footnote">2</a></sup> with a value log and is based on a paper titled <a href="https://www.usenix.org/system/files/conference/fast16/fast16-papers-lu.pdf">WiscKey: Separating Keys from Values in SSD-conscious Storage</a></p> </blockquote> <p>A log-structured merge tree (LSM tree) is a storage engine data structure typically used when dealing with write-heavy workloads. The write path is optimized by performing sequential writes on the disk. To perform sequential writes on disk, the LSM tree buffers the data in memory and then flushes to disk once the in-memory buffer is full. To ensure the durability of the data, every write is first added to a WAL (write-ahead log) file before updating the in-memory buffer. The in-memory buffer is called the memtable. After the memtable is full, it is converted to SSTable (sorted string table) and flushed to disk.</p> <p>Every <code class="language-plaintext highlighter-rouge">get(key)</code> operation first queries the in-memory memtable(s) to see if the value for the given key exists in memory. If not, the <code class="language-plaintext highlighter-rouge">get(key)</code> operation retrieves the value from SSTables (disk-based structures).</p> <p>SSTables are organized into levels. Below is the organization of SSTables in <a href="https://github.com/google/leveldb">LevelDB</a></p> <div class="align-center"> <img style="padding-left: 0; max-width: 90%" src="/assets/img/pexels/sstable.png" class="wp-image-878" /> </div> <p>The size of the SSTables (or the files) increases as we go down the levels.</p> <p>One way to perform a <code class="language-plaintext highlighter-rouge">get(key)</code> operation on SSTables is to scan all the SSTables starting from <code class="language-plaintext highlighter-rouge">level=0 to level=N</code> and return the value as soon as it is found. This approach is brute-force, and it means a lot of IO costs.</p> <p>This approach can be optimized by using a bloom filter. Let’s see how:</p> <ol> <li>Every SSTable can be associated with its filter.</li> <li>All the keys of an SSTable will be added to its bloom filter.</li> </ol> <blockquote> <p>SSTable (sorted string table) contains all the key-value pairs sorted by key. SSTable file is organized into multiple sections (or blocks), including index block, bloom filter block, data block and footer block etc. BadgerDB puts the bloom filter (the byte array of the bloom filter) inside the SSTable.</p> </blockquote> <p>To perform a <code class="language-plaintext highlighter-rouge">get(key)</code> operation on an SSTable, the application will query the bloom filter associated with it.</p> <blockquote> <p>To query the bloom filter associated with an SSTable, the bloom filter block (byte array) needs to be read in memory. The information about the begin and the end offsets of the bloom filter is encoded in the footer block of the SSTable.</p> </blockquote> <p>If the bloom filter returns <code class="language-plaintext highlighter-rouge">true</code>, the application will scan the data block of the SSTable to get the value of the given key. This also means that the bloom filter will check an SSTable even in the case of false positives.</p> <p>Let’s now look at BadgerDB’s code to understand the use of the bloom filter.</p> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">//some fields omitted</span>
<span class="k">type</span> <span class="n">levelsController</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">levels</span> <span class="p">[]</span><span class="o">*</span><span class="n">levelHandler</span>
<span class="p">}</span>

<span class="c">//get searches for a given key in all the levels of the LSM tree starting with startLevel</span>
<span class="c">//code omitted</span>
<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">levelsController</span><span class="p">)</span> <span class="n">get</span><span class="p">(</span><span class="n">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">,</span> <span class="n">maxVs</span> <span class="n">y</span><span class="o">.</span><span class="n">ValueStruct</span><span class="p">,</span> <span class="n">startLevel</span> <span class="kt">int</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">ValueStruct</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>   
    <span class="n">version</span> <span class="o">:=</span> <span class="n">y</span><span class="o">.</span><span class="n">ParseTs</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">level</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">s</span><span class="o">.</span><span class="n">levels</span> <span class="p">{</span>
        <span class="c">// Ignore all levels below startLevel. This is useful for GC when L0 is kept in memory.</span>
        <span class="k">if</span> <span class="n">level</span><span class="o">.</span><span class="n">level</span> <span class="o">&lt;</span> <span class="n">startLevel</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
        <span class="c">//invoke levelHandler to get the value for the given key</span>
        <span class="n">valueStruct</span><span class="p">,</span> <span class="n">err</span> <span class="o">:=</span> <span class="n">level</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>        
        <span class="k">if</span> <span class="n">valueStruct</span><span class="o">.</span><span class="n">Version</span> <span class="o">==</span> <span class="n">version</span> <span class="p">{</span>
            <span class="k">return</span> <span class="n">valueStruct</span><span class="p">,</span> <span class="no">nil</span>
        <span class="p">}</span>     
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">maxVs</span><span class="p">,</span> <span class="no">nil</span>
<span class="p">}</span>
</code></pre></div></div> <p>SSTables are organized into multiple levels and <code class="language-plaintext highlighter-rouge">levelsController</code> is an abstraction to represent these levels. Each level is represented by another abstraction called <code class="language-plaintext highlighter-rouge">levelHandler</code>. <code class="language-plaintext highlighter-rouge">levelsController</code> maintains an array of levels or <code class="language-plaintext highlighter-rouge">levelHandler</code>. The <code class="language-plaintext highlighter-rouge">get</code> method does the following:</p> <ol> <li>Scan through all the levels greater than or equal to the <code class="language-plaintext highlighter-rouge">startLevel</code>.</li> <li>For each level, ask the <code class="language-plaintext highlighter-rouge">levelHandler</code> to get the value for the key by invoking <code class="language-plaintext highlighter-rouge">level.get(key)</code>.</li> <li>Match the key version and return the received value if it matches.</li> </ol> <p><code class="language-plaintext highlighter-rouge">levelHandler</code> represents a level and maintains an array of all the SSTables for that level. <code class="language-plaintext highlighter-rouge">get</code> method attempts to return the value with the latest version:</p> <div class="language-golang highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c">//some fields omitted</span>
<span class="k">type</span> <span class="n">levelHandler</span> <span class="k">struct</span> <span class="p">{</span>
    <span class="n">tables</span>   <span class="p">[]</span><span class="o">*</span><span class="n">table</span><span class="o">.</span><span class="n">Table</span>
    <span class="n">level</span>    <span class="kt">int</span>
<span class="p">}</span>

<span class="c">// get returns value for a given key or the key after that. If not found, return nil.</span>
<span class="k">func</span> <span class="p">(</span><span class="n">lHandler</span> <span class="o">*</span><span class="n">levelHandler</span><span class="p">)</span> <span class="n">get</span><span class="p">(</span><span class="n">key</span> <span class="p">[]</span><span class="kt">byte</span><span class="p">)</span> <span class="p">(</span><span class="n">y</span><span class="o">.</span><span class="n">ValueStruct</span><span class="p">,</span> <span class="kt">error</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">tables</span><span class="p">,</span> <span class="n">decr</span> <span class="o">:=</span> <span class="n">lHandler</span><span class="o">.</span><span class="n">getTableForKey</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    
    <span class="c">//get the key without a timestamp</span>
    <span class="n">keyNoTs</span> <span class="o">:=</span> <span class="n">y</span><span class="o">.</span><span class="n">ParseKey</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
    
    <span class="c">//get the hash of the key</span>
    <span class="n">hash</span>    <span class="o">:=</span> <span class="n">y</span><span class="o">.</span><span class="n">Hash</span><span class="p">(</span><span class="n">keyNoTs</span><span class="p">)</span>
    
    <span class="k">var</span> <span class="n">maxVs</span> <span class="n">y</span><span class="o">.</span><span class="n">ValueStruct</span>
    <span class="k">for</span> <span class="n">_</span><span class="p">,</span> <span class="n">table</span> <span class="o">:=</span> <span class="k">range</span> <span class="n">tables</span> <span class="p">{</span>
        <span class="c">//if the table does not have the hash of the key, there is no point in scanning the table</span>
        <span class="c">//(*) bloom filter lookup</span>
        <span class="k">if</span> <span class="n">table</span><span class="o">.</span><span class="n">DoesNotHave</span><span class="p">(</span><span class="n">hash</span><span class="p">)</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
    
        <span class="c">//create an iterator over the table</span>
        <span class="n">iterator</span> <span class="o">:=</span> <span class="n">table</span><span class="o">.</span><span class="n">NewIterator</span><span class="p">(</span><span class="m">0</span><span class="p">)</span>
        <span class="k">defer</span> <span class="n">iterator</span><span class="o">.</span><span class="n">Close</span><span class="p">()</span>
    
        <span class="c">//seek to the key in SSTable</span>
        <span class="n">iterator</span><span class="o">.</span><span class="n">Seek</span><span class="p">(</span><span class="n">key</span><span class="p">)</span>
        <span class="k">if</span> <span class="o">!</span><span class="n">iterator</span><span class="o">.</span><span class="n">Valid</span><span class="p">()</span> <span class="p">{</span>
            <span class="k">continue</span>
        <span class="p">}</span>
    
        <span class="c">//store the value with the maximum version</span>
        <span class="k">if</span> <span class="n">y</span><span class="o">.</span><span class="n">SameKey</span><span class="p">(</span><span class="n">key</span><span class="p">,</span> <span class="n">iterator</span><span class="o">.</span><span class="n">Key</span><span class="p">())</span> <span class="p">{</span>
            <span class="k">if</span> <span class="n">version</span> <span class="o">:=</span> <span class="n">y</span><span class="o">.</span><span class="n">ParseTs</span><span class="p">(</span><span class="n">iterator</span><span class="o">.</span><span class="n">Key</span><span class="p">());</span> <span class="n">maxVs</span><span class="o">.</span><span class="n">Version</span> <span class="o">&lt;</span> <span class="n">version</span> <span class="p">{</span>
                <span class="n">maxVs</span>       <span class="o">=</span> <span class="n">iterator</span><span class="o">.</span><span class="n">ValueCopy</span><span class="p">()</span>
                <span class="n">maxVs</span><span class="o">.</span><span class="n">Version</span> <span class="o">=</span> <span class="n">version</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">return</span> <span class="n">maxVs</span><span class="p">,</span> <span class="n">decr</span><span class="p">()</span>
<span class="p">}</span>
</code></pre></div></div> <p>The working of the <code class="language-plaintext highlighter-rouge">get</code> method of <code class="language-plaintext highlighter-rouge">levelHandler</code> can be summarized as:</p> <ol> <li>Get the hash of the key without a timestamp.</li> <li>Iterate through the tables (SSTables) and if the current table does not contain the given key, skip it and move to the following table.</li> <li>If the table <strong>can contain</strong> the given key, create an iterator over the table.</li> <li>Use <code class="language-plaintext highlighter-rouge">iterator.Seek</code> to seek to the given key.</li> <li>Store the value of the matching key only if its version is greater than the existing version.</li> <li>Return the value (value is represented by <code class="language-plaintext highlighter-rouge">ValueStruct</code>).</li> </ol> <p><code class="language-plaintext highlighter-rouge">table.DoesNotHave(hash)</code> does a bloom filter lookup. <code class="language-plaintext highlighter-rouge">DoesNotHave</code> returns true if the table does not have the key.</p> <h3 id="code">Code</h3> <p>The code for this article is available <a href="https://github.com/SarthakMakhija/probabilistic-data-structures/tree/main/membership">here</a>.</p> <h3 id="references">References</h3> <ul> <li><a href="https://en.wikipedia.org/wiki/Bloom_filter">Bloom filter</a></li> <li><a href="https://freecontent.manning.com/all-about-bloom-filters/">Bloom filter</a></li> <li><a href="https://github.com/dgraph-io/badger">BadgerDB</a></li> <li><a href="https://segmentfault.com/a/1190000041198407/en">LSM tree</a></li> </ul> <div class="footnotes" role="doc-endnotes"> <ol> <li id="fn:1" role="doc-endnote"> <p><a href="https://www.geeksforgeeks.org/introduction-to-the-probabilistic-data-structure/">Probabilistic data structures</a> provide approximate answers to queries about a large dataset rather than exact answers. These data structures are designed to handle large amounts of data in real-time by making trade-offs between accuracy and time and space efficiency. <a href="#fnref:1" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> <li id="fn:2" role="doc-endnote"> <p><a href="https://yetanotherdevblog.com/lsm/">LSM Tree</a> A log-structured merge tree (LSM tree) is a data structure typically used when dealing with write-heavy workloads. The write path is optimized by performing sequential writes. <a href="#fnref:2" class="reversefootnote" role="doc-backlink">&#8617;</a></p> </li> </ol> </div> </section> <!-- Social media shares --> <div class="share-buttons"> <ul class="share-buttons"> <div class="meta">Share</div> <li> <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Ftech-lessons.in%2Fbloom-filter%2F" target="_blank" title=" Facebook"> <i class="fa fa-facebook-square fa-2x" aria-hidden="true"></i> <span class="sr-only">Share on Facebook</span> </a> </li> <li> <a href="https://twitter.com/intent/tweet?text=Bloom+filter%20https%3A%2F%2Ftech-lessons.in%2Fbloom-filter%2F" target="_blank" title=""> <i class="fa fa-twitter-square fa-2x" aria-hidden="true"></i> <span class="sr-only">Tweet</span> </a> </li> <li> <a href="http://www.linkedin.com/shareArticle?mini=true&url=https://tech-lessons.in/bloom-filter/&title=Bloom+filter%20%7C%20tech-lessons.in&summary=&source=https://tech-lessons.in/bloom-filter/" target="_blank" title=" LinkedIn"> <i class="fa fa-linkedin fa-2x" aria-hidden="true"></i> <span class="sr-only">Share on LinkedIn</span> </a> </li> </ul> </div> <!-- Tag list --> <footer> <div class="tag-list"> <div class="meta">Tags</div> <a class="button" href="/tags#Bloom+filter"> <p><i class="fa fa-tag fa-fw"></i> Bloom filter</p> </a> <a class="button" href="/tags#Probabilistic+data+structures"> <p><i class="fa fa-tag fa-fw"></i> Probabilistic data structures</p> </a> <a class="button" href="/tags#Storage+engine"> <p><i class="fa fa-tag fa-fw"></i> Storage engine</p> </a> </div> </footer> </article> <!-- Disqus --> <div class="comments"> <div id="disqus_thread"></div> <script type="text/javascript"> var disqus_shortname = 'techlessons'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script> <noscript>Please enable JavaScript to view comments.</noscript> </div> <!-- Post navigation --> <div id="post-nav"> <div id="next-post"> <a alt="Count-min sketch" href="/count-min-sketch/"> <p>Next post</p> Count-min sketch </a> </div> </div> <!-- To change color of links in the page --> <style> header#main { background-repeat:no-repeat; background-image: url('/assets/img/pexels/bloomfilter_title.png'); } </style> </div> <footer class="site-footer"> <p class="text"> tech-lessons.in © 2020. All Rights Reserved. Powered by <a href='https://jekyllrb.com/'>Jekyll</a> </p> <div class="footer-icons"> <ul> <li> <a href="https://github.com/sarthakmakhija" title="Follow on GitHub"> <span class="fa-stack fa-lg"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i> </span> </a> </li> <li> <a href="https://www.linkedin.com/in/sarthak-makhija-7a165a55/" title="Follow on LinkedIn"> <span class="fa-stack fa-lg"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i> </span> </a> </li> </ul> <ul> </ul> </div> </footer> </body> </html>
