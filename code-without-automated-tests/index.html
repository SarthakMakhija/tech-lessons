<!DOCTYPE html> <!-- Type on Strap jekyll theme v2.0.0 Copyright 2016-2019 Sylhare Theme free for personal and commercial use under the MIT license https://github.com/sylhare/Type-on-Strap/blob/master/LICENSE --> <html lang="en"> <head> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"> <!-- CSS --> <link rel="stylesheet" href="/assets/css/main.css"> <!--Favicon--> <link rel="shortcut icon" href="/assets/favicon.png" type="image/x-icon"> <!-- Canonical --> <link rel="canonical" href="https://tech-lessons.in/code-without-automated-tests/"> <!-- KaTeX 0.8.3 --> <!-- if you have any issue check https://github.com/KaTeX/KaTeX --> <!-- Google Analytics --> <!-- End Google Analytics --> <!-- seo tags --> <!-- Begin Jekyll SEO tag v2.7.1 --> <title>Code without automated tests? Are we serious? | tech-lessons.in</title> <meta name="generator" content="Jekyll v4.2.1" /> <meta property="og:title" content="Code without automated tests? Are we serious?" /> <meta name="author" content="Sarthak Makhija" /> <meta property="og:locale" content="en_US" /> <meta name="description" content="What would it really mean to write code without automated tests, to deliver software without automated tests. Why would someone even think of writing code today and adding tests later?" /> <meta property="og:description" content="What would it really mean to write code without automated tests, to deliver software without automated tests. Why would someone even think of writing code today and adding tests later?" /> <link rel="canonical" href="https://tech-lessons.in/code-without-automated-tests/" /> <meta property="og:url" content="https://tech-lessons.in/code-without-automated-tests/" /> <meta property="og:site_name" content="tech-lessons.in" /> <meta property="og:type" content="article" /> <meta property="article:published_time" content="2021-10-27T00:00:00+05:30" /> <meta name="twitter:card" content="summary" /> <meta property="twitter:title" content="Code without automated tests? Are we serious?" /> <script type="application/ld+json"> {"url":"https://tech-lessons.in/code-without-automated-tests/","author":{"@type":"Person","name":"Sarthak Makhija"},"headline":"Code without automated tests? Are we serious?","dateModified":"2021-10-27T00:00:00+05:30","datePublished":"2021-10-27T00:00:00+05:30","@type":"BlogPosting","description":"What would it really mean to write code without automated tests, to deliver software without automated tests. Why would someone even think of writing code today and adding tests later?","mainEntityOfPage":{"@type":"WebPage","@id":"https://tech-lessons.in/code-without-automated-tests/"},"@context":"https://schema.org"}</script> <!-- End Jekyll SEO tag --> <!-- Manual seo tags --> <!-- <title>Code without automated tests? Are we serious? | tech-lessons.in</title> <meta name="description" content="What would it really mean to write code without automated tests, to deliver software without automated tests. Why would someone even think of writing code to..."> --> </head> <script defer=true src="/assets/js/main.min.js"></script> <body> <header class="site-header"> <!-- Toggle menu --> <nav class="clear"> <a aria-label="pull" id="pull" class="toggle" href="#"> <i class="fa fa-bars fa-lg"></i> </a> <!-- Brand Logo --> <a class="navbar-brand" href="/"> <img src="/assets/img/pexels/logo.png" alt="tech-lessons" title="tech-lessons"> </a> <!-- Menu --> <ul class="hide"> <li class="separator"> |</li> <li> <a class="clear" aria-label="Home" title="Home" href="/"> <i class="fa fa-fw fa-home" aria-hidden="true"></i> Home </a> </li> <li class="separator"> |</li> <li> <a class="clear" aria-label="Search" title="Search" href="/search/"> <i class="fa fa-fw fa-search" aria-hidden="true"></i> Search </a> </li> <li class="separator"> |</li> <li> <a class="clear" aria-label="Tags" title="Tags" href="/tags/"> <i class="fa fa-fw fa-tags" aria-hidden="true"></i> Tags </a> </li> <li class="separator"> |</li> <li> <a class="clear" aria-label="About Me" title="About Me" href="/about/"> <i class="fa fa-fw fa-male" aria-hidden="true"></i> About Me </a> </li> </ul> </nav> </header> <div class="content"> <meta property="og:url" content="/code-without-automated-tests/" /> <meta property="og:type" content="article" /> <meta property="og:title" content="Code without automated tests? Are we serious?" /> <meta property="og:description" content="What would it really mean to write code without automated tests, to deliver software without automated tests. Why would someone even think of writing code today and adding tests later?" /> <meta property="og:image" content="assets/img/pexels/code-without-tests.png" /> <article class="feature-image"> <header id="main" style=""></header> <section class="post-content"> <h1 id="Code+without+automated+tests%3F+Are+we+serious%3F" class="title">Code without automated tests? Are we serious?</h1> <p>Automated tests are an essential part of every piece of code that we write. The benefits of these tests are so compelling that it does not even make sense to think about writing code without tests or writing code today and adding tests later. Despite the benefits, we still see code without tests, we still see ideas like “writing code today and adding tests when the delivery pressure reduces” floating around.</p> <p>I don’t have real reasons as to why such ideas would float around, but I can speculate.</p> <p><strong>Speculation (1)</strong> Adding tests takes a lot of time</p> <p><strong>Speculation (2)</strong> There is a lot of delivery pressure today and there is a firm belief that tomorrow will be better and that is when we will go and add tests</p> <p>What I want to do as a part of this article is try and understand how would our world look like with such ideas and does it even make sense to consider them. With that said, I will keep the idea of TDD aside for this article.</p> <blockquote class="wp-block-quote"> <p>What would it really mean to write code without automated tests, to deliver software without automated tests. Why would someone even think of writing code today and adding tests later?</p> </blockquote> <h3 id="does-it-really-take-time-to-add-tests">Does it really take time to add tests?</h3> <p>One of the possible arguments around not adding automated tests could be the “time”.</p> <blockquote class="wp-block-quote"> <p>Argument1: It takes time to add tests and time is really costly. We need to finish our story and there is this delivery pressure.</p> </blockquote> <p>Let’s see how fair is that argument by considering a method <code class="language-plaintext highlighter-rouge">leftShift</code> which left shifts the elements of a slice by 1, let’s assume non-empty slice for now.</p> <figure class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">type</span> <span class="n">slice</span> <span class="k">struct</span> <span class="p">{</span>
	<span class="n">elements</span> <span class="p">[]</span><span class="kt">int</span>
<span class="p">}</span>

<span class="k">func</span> <span class="n">newSlice</span><span class="p">(</span><span class="n">elements</span> <span class="p">[]</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span><span class="n">slice</span> <span class="p">{</span>
	<span class="k">return</span> <span class="o">&amp;</span><span class="n">slice</span><span class="p">{</span><span class="n">elements</span><span class="o">:</span> <span class="n">elements</span><span class="p">}</span>
<span class="p">}</span>

<span class="k">func</span> <span class="p">(</span><span class="n">s</span> <span class="o">*</span><span class="n">slice</span><span class="p">)</span> <span class="n">leftShift</span><span class="p">()</span> <span class="p">{</span>
	<span class="k">for</span> <span class="n">index</span> <span class="o">:=</span> <span class="m">0</span><span class="p">;</span> <span class="n">index</span> <span class="o">&lt;</span> <span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">;</span> <span class="n">index</span><span class="o">++</span> <span class="p">{</span>
		<span class="n">s</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="n">index</span><span class="o">+</span><span class="m">1</span><span class="p">]</span>
	<span class="p">}</span>
	<span class="n">s</span><span class="o">.</span><span class="n">elements</span><span class="p">[</span><span class="nb">len</span><span class="p">(</span><span class="n">s</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span><span class="o">-</span><span class="m">1</span><span class="p">]</span> <span class="o">=</span> <span class="m">0</span>
<span class="p">}</span></code></pre></figure> <div class="align-center"> <img style="padding-left: 0; max-width: 50%" src="/assets/img/pexels/left-shift-slice.png" class="wp-image-878" /> </div> <p>What this code does is pretty simple -</p> <ul> <li>drops the element at index 0</li> <li>moves each element to its left</li> <li>puts a zero at the last index</li> </ul> <p>Let’s add a unit test for the same.</p> <figure class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">package</span> <span class="n">main</span>

<span class="k">import</span> <span class="p">(</span>
	<span class="s">"reflect"</span>
	<span class="s">"testing"</span>
<span class="p">)</span>

<span class="k">func</span> <span class="n">TestLeftShiftsANotEmptySliceBy1</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">slice</span> <span class="o">:=</span> <span class="n">newSlice</span><span class="p">([]</span><span class="kt">int</span><span class="p">{</span><span class="m">10</span><span class="p">,</span> <span class="m">20</span><span class="p">,</span> <span class="m">30</span><span class="p">,</span> <span class="m">40</span><span class="p">,</span> <span class="m">50</span><span class="p">})</span>
	<span class="n">slice</span><span class="o">.</span><span class="n">leftShift</span><span class="p">()</span>

	<span class="n">expected</span> <span class="o">:=</span> <span class="p">[]</span><span class="kt">int</span><span class="p">{</span><span class="m">20</span><span class="p">,</span> <span class="m">30</span><span class="p">,</span> <span class="m">40</span><span class="p">,</span> <span class="m">50</span><span class="p">,</span> <span class="m">0</span><span class="p">}</span>

	<span class="k">if</span> <span class="o">!</span><span class="n">reflect</span><span class="o">.</span><span class="n">DeepEqual</span><span class="p">(</span><span class="n">expected</span><span class="p">,</span> <span class="n">slice</span><span class="o">.</span><span class="n">elements</span><span class="p">)</span> <span class="p">{</span>
		<span class="n">t</span><span class="o">.</span><span class="n">Fatalf</span><span class="p">(</span><span class="s">"Expected %v, received %v after performing left shift"</span><span class="p">,</span>
			<span class="n">expected</span><span class="p">,</span>
			<span class="n">slice</span><span class="o">.</span><span class="n">elements</span><span class="p">,</span>
		<span class="p">)</span>
	<span class="p">}</span>
<span class="p">}</span></code></pre></figure> <p>As a part of this test, we perform a left shift on a slice and assert the elements against the expected after shift operation. That’s really it.</p> <p>It only requires us to understand how to write unit tests. Honestly, it doesn’t take a lot of time to add tests, be it unit tests, integration tests, contract tests or API tests, once we understand a few things including -</p> <ul> <li>What do these tests stand for <ul> <li>It is essential to understand what is “unit” in a unit test, what is an “integration” test etc</li> </ul> </li> <li>What purpose do these tests serve <ul> <li>It is essential to answer questions like “why can’t we have all integration tests and zero unit tests”</li> </ul> </li> <li>And, how to write these tests <ul> <li>It is essential to answer questions like “how do I write tests in X programming language with Y framework”</li> </ul> </li> </ul> <p>Once we answer all these questions, it doesn’t take a lot of time to add tests.</p> <p>There is still a forked argument that I can think of.</p> <blockquote class="wp-block-quote"> <p>Argument2: What we build is not as simple as left shifting a slice, our systems are complex and fancy. We can't just add one test and be done. Hence, adding so many tests would take time, which of course we don't have.</p> </blockquote> <p>The answer to this lies in the argument itself. If left shifting a slice needs an automated test, any fancy and complex system would need them too.</p> <p>And yes, your system is not as simple as left shifting some elements but at the same time, the fancy system is not built in a day. It is built piece by piece gradually, so why not add tests for every small piece that gets built.</p> <p><em>Important Side note:</em> If we remove the assumption that our slice is non-empty (ie; <code class="language-plaintext highlighter-rouge">elements</code> within the <code class="language-plaintext highlighter-rouge">slice</code> struct is non-empty), <code class="language-plaintext highlighter-rouge">leftSlice</code> method will fail. In fact, at this point in time, the only way to conclude that an empty slice will result in a failure is by walking through the code. Once we have the test for the same, not only does it give us a safety net but also serves as a <strong>live documentation</strong> which gets updated everytime the behavior of the changes.</p> <h3 id="code-today-and-add-tests-later">Code today and add tests later</h3> <p>One of the other theories that I have heard is “let’s code today and add tests tomorrow or maybe later”. There could be multiple reasons for this theory but probably, “delivery pressure”, and a beautiful belief “code without automated tests is ok” should be the main reasons for this wonderful idea to pop up.</p> <p>Let’s see what would happen if we write code today and add tests later, forget TDD. Consider our favorite method <code class="language-plaintext highlighter-rouge">leftShift</code> and assume -</p> <ul> <li>no tests are written</li> <li>a week has passed by and now we are adding tests</li> </ul> <p>Let’s look at various challenges that would come up -</p> <p><strong>Boring</strong></p> <p>I don’t have a better word for this stuff. We need to look at the code and understand what it does. Once that understanding is built, we need to write tests. One might argue, “Why build an understanding”, just write “characterization tests”. Sure, but how would you figure out corner cases, you need some background to think about corner cases.</p> <p>This stuff just seems boring to me, looking at the code, figuring out various cases that too after 7 days, and adding tests.</p> <p><strong>Possibility of missing corner cases</strong></p> <p>There is a good possibility that we will miss corner cases if we decide to add tests later because the cases, or the context is not fresh anymore.</p> <p><strong>Lack of motivation</strong></p> <p>What would be the motivation to add tests 7 days later? Lack of coverage in Sonar?</p> <p>Well, someone might even say this - “the code is already working somewhere (in Dev, QA or even in prod), why bother adding tests now”. It is so easy for such a thought process to set in and once it sets in, tests would only be added for finishing some formality.</p> <p><strong>Delayed refactoring</strong></p> <p>In the absence of tests, refactoring for various parts of code will get delayed. This in turn has a huge drawback, a method which is 50 lines today might grow to 100 lines in 7 days. Not only are the number of code smells going to increase later, but even refactoring might become tricky or may take longer.</p> <p>What are we basing theory of “adding code today and tests later” on? How is tomorrow going to be any different? Is sun going to shine too brightly tomorrow? Are we going to stop churning stories tomorrow? Are we going to just add tests and do nothing else?</p> <p>The overall idea is just flawed.</p> <p>I know I could have hurt your emotions, but let’s take a look at some benefits of automated tests and see the real gains.</p> <h3 id="benefits-of-automated-tests">Benefits of automated tests</h3> <p>Automated tests provide a lot of benefits. I will list a few -</p> <p><strong>Provide confidence</strong></p> <p>Automated tests are like a certification for a working code. I know <code class="language-plaintext highlighter-rouge">leftShift</code> is working properly everytime its tests pass. In fact, automated tests act as a mapping between questions and answers. I can ask various questions to unit tests -</p> <ul> <li>How would <code class="language-plaintext highlighter-rouge">leftShift</code> behave if I pass a slice with empty elements</li> <li>How would <code class="language-plaintext highlighter-rouge">leftShift</code> behave if I pass a slice with a single element</li> <li>How would <code class="language-plaintext highlighter-rouge">leftShift</code> behave if I pass a slice with N elements, where N &gt; 1</li> <li>How would <code class="language-plaintext highlighter-rouge">leftShift</code> behave if I pass a slice with N elements containing duplicates, where N &gt; 1</li> <li>How would <code class="language-plaintext highlighter-rouge">leftShift</code> behave if I invoke the method with a nil receiver, ie; <code class="language-plaintext highlighter-rouge">s</code> of <code class="language-plaintext highlighter-rouge">(s *slice)</code> is nil</li> </ul> <p>It is a huge confidence booster :) if all these questions are answered by passing tests.</p> <p><strong>Act as safety net</strong></p> <p>Automated tests are a brilliant safety net, I can go ahead and refactor code without any fear. I know I have tests which would fail loudly if I mess things up, so there is no fear of making mistakes while refactoring.</p> <p>I think it would be a very courageous move to refactor code without tests. (<em>Honestly, I don’t know if it is a courageous move or a stupid move.</em>) But, if I decide to refactor code without tests, I think I would be blocked by anxiety, there will be a constant banging in the head - what if refactoring breaks the code, can I just stop refactoring here, is it really necessary to refactor etc. With tests written for the code, there is no case of anxiety or fear.</p> <blockquote class="wp-block-quote"> Tests are anxiety busters :), especially unit tests </blockquote> <p><strong>Provide quick feedback</strong></p> <p>Automated tests provide quick feedback on any change that is done in the code. Assume (just assume) we are refactoring a long method, and we do not have tests. Let’s try to imagine what the world would look like now -</p> <ol> <li>Extract a piece of code into a new method</li> <li>Run the entire application, send some requests and see if the extraction worked</li> <li>It worked, congratulations</li> <li>Rename the extracted method</li> <li>Run the entire application, send some requests and see if renaming worked</li> <li>It worked, congratulations again</li> <li>Change the number of parameters of the extracted method</li> <li>Run the entire application, send some requests and see if the change in number of parameters worked</li> <li>You really deserve congratulations</li> <li>The method is feature envy, let’s move it to the right class</li> </ol> <p>…</p> <p>If there were unit tests, we could have run them every time on every change, and it would have been way quicker than running the entire application N times. There is a strange part that I don’t seem to understand, I will explain. If the argument for not writing tests or deferring writing tests is “lack of time”, then, where would you get time for running the application N times to validate if a change has worked.</p> <p><strong>Provide ability to move fast under pressure</strong></p> <p>Automated tests provide the ability to move fast under pressure. Let’s say a production defect is found and if we have unit tests, we are SAFE. Under production issue pressure what we don’t want to do is make a small problem explode into a bigger one. With unit tests in place, all we do is -</p> <ul> <li>replicate the issue by adding a failing test</li> <li>make the necessary code changes to pass the test</li> <li>run the entire test suite, if all is “green”, we are good</li> </ul> <p><em>Important Side note:</em> What we also don’t want to do is “just write UI tests in a web application”. We need quick feedback for any changes that we make in the code, and it becomes even more essential to figure out what kind of tests would make more sense for a given situation.</p> <p>For instance, if there is a method which sorts all the “orders” based on “order date”. It does not make sense to test it as a part of some UI based test, all this method does is “sorting of a collection based on an attribute”. Just add unit tests for the use-case and that is good enough to prove that a part of the functionality (sorting) is working fine.</p> <p><strong>Act as documentation</strong></p> <p>Automated tests act as documentation for what the code does. I don’t need to go through <code class="language-plaintext highlighter-rouge">leftShift</code> method to understand its behavior -</p> <ul> <li>what if it is invoked with a slice containing empty elements</li> <li>what if it is invoked with a slice containing just one element</li> </ul> <p>I will just go and look at the tests. In fact, adding tests is one way of creating a trail of understanding for the readers. Readers of the code don’t need to make too much of an effort to find such answers, they can directly look at the tests and find <em>most</em> of the answers.</p> <p><strong>Provide an opportunity to think from a client’s perspective</strong></p> <p>Automated tests give an opportunity to think from a client’s perspective and provide a lot of opportunities to improve the API.</p> <p>Let’s imagine a struct <code class="language-plaintext highlighter-rouge">LinkedList</code> and I am required to add a behavior which rotates a linked list left by N. (Assume, I am not doing TDD). I start with a behavior called <code class="language-plaintext highlighter-rouge">rotateList(n int)</code>, build it and now I go on to adding a test. Test would look something like this -</p> <figure class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">func</span> <span class="n">TestRotatesALinkedListBy1</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">linkedList</span> <span class="o">:=</span> <span class="n">LinkedList</span><span class="p">{}</span>
	<span class="n">linkedList</span><span class="o">.</span><span class="n">rotateList</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
    <span class="o">....</span>
<span class="p">}</span></code></pre></figure> <p>One of the first things that I notice is the name of the method <code class="language-plaintext highlighter-rouge">rotateList</code>. In the expression <code class="language-plaintext highlighter-rouge">linkedList.rotateList</code>, do I need to call the behavior as <code class="language-plaintext highlighter-rouge">rotateList</code> or just <code class="language-plaintext highlighter-rouge">rotate</code> is good enough because it is invoked on a list. I would go and rename it to <code class="language-plaintext highlighter-rouge">rotate</code> and now my client call looks like <code class="language-plaintext highlighter-rouge">linkedList.rotate(1)</code>.</p> <p>Once I start paying attention to the entire expression <code class="language-plaintext highlighter-rouge">linkedList.rotate(1)</code>, I would realize <code class="language-plaintext highlighter-rouge">rotate(1)</code> is not making sense. It does not tell the clients or the readers that the intention is to rotate list by 1. What if it were renamed to <code class="language-plaintext highlighter-rouge">rotateBy()</code>, it would make my client call look like this <code class="language-plaintext highlighter-rouge">linkedList.rotateBy(1)</code></p> <p>Now, probably the last thing would be, <code class="language-plaintext highlighter-rouge">linkedList.rotateBy(1)</code> does not tell the clients about the direction of rotation. What if it were renamed to <code class="language-plaintext highlighter-rouge">rotateLeftBy()</code>, it would make my client call look like this <code class="language-plaintext highlighter-rouge">linkedList.rotateLeftBy(1)</code></p> <figure class="highlight"><pre><code class="language-golang" data-lang="golang"><span class="k">func</span> <span class="n">TestRotatesALinkedListLeftBy1</span><span class="p">(</span><span class="n">t</span> <span class="o">*</span><span class="n">testing</span><span class="o">.</span><span class="n">T</span><span class="p">)</span> <span class="p">{</span>
	<span class="n">linkedList</span> <span class="o">:=</span> <span class="n">LinkedList</span><span class="p">{}</span>
	<span class="n">linkedList</span><span class="o">.</span><span class="n">rotateLeftBy</span><span class="p">(</span><span class="m">1</span><span class="p">)</span>
    <span class="o">....</span>
<span class="p">}</span></code></pre></figure> <blockquote class="wp-block-quote"> Tests actually influence the design of class - at micro &amp; macro levels. And actually help write more intuitive code (because they are written from the outside-in perspective, it makes for more readable code... than code which is influenced by "implementation details"). </blockquote> <p>By not adding automated tests or by deferring addition of tests, we are just losing all these advantages.</p> <h3 id="would-you-buy-a-car-without-brakes">Would you buy a car without brakes?</h3> <p>One of the things that the automated tests provide is a “safety net” which in turn allows us to make changes in code with confidence. I am not sure why do we even call software delivery a delivery, without automated tests. Let’s try to draw an analogy between “building software” and “manufacturing car”.</p> <blockquote class="wp-block-quote"> <p>If it is ok to write code without tests, to deliver software without tests, then we should be ok to buy a car without brakes. </p> </blockquote> <p>How would it feel if a car manufacturer told us to buy a car without brakes. If adding tests in the code can be deferred or be considered non-essential, why can’t brakes in a car be considered non-essential? The point is why can’t brakes be added later on if time permits, if there is no delivery pressure or, if there are less delivery orders?</p> <p>We really need confidence in the car that we are driving, we also need confidence in the brakes, and if confidence is such an important thing, then why not build confidence in the code by adding automated tests for every piece of code that we write?</p> <p><em>If our software is a car, then automated tests are the brakes.</em> Like we said, we need confidence in the brakes as well which essentially means, it is not just about writing tests because of some code coverage policy in the organization, it is about “building a trail of understanding for all the readers”, about stating “what is it that a piece of code does”, “when does it fail”, “what kind of inputs does it take” and so many other things.</p> <blockquote class="wp-block-quote"> It is our responsibility to ensure these "brakes" exist in the code (or the system) and they are reliable. They should not exist just for the sake of existing. </blockquote> <h3 id="conclusion">Conclusion</h3> <p>I don’t see any reason for not writing tests or deferring the addition of tests. I think once you get addicted to “quick feedback”, this point of developing without tests, writing code today and adding tests later and not doing TDD automatically goes away.</p> <p>If a team finds it difficult to write tests, or it takes too long to write tests, then the team needs to practice it more. Practice till it becomes a habit. Not adding tests is not a solution. It is an easy hack but very expensive.</p> <p>If a team believes their software has been working without issues and that too without tests, I think it is just a matter of “when”, not “if”. Try to get better at things before it all comes crashing down.</p> <p>If a team believes there is delivery pressure today and tests can be added tomorrow, then the team needs to be sure of one thing - “That tomorrow is never coming”.</p> <h3 id="mentions">Mentions</h3> <p>I would like to thank <a href="https://life-lessons.in/">Gurpreet Luthra</a> for providing feedback on the article. Thank you Gurpreet.</p> </section> <!-- Social media shares --> <div class="share-buttons"> <ul class="share-buttons"> <div class="meta">Share</div> <li> <a href="https://www.facebook.com/sharer/sharer.php?u=https%3A%2F%2Ftech-lessons.in%2Fcode-without-automated-tests%2F" target="_blank" title=" Facebook"> <i class="fa fa-facebook-square fa-2x" aria-hidden="true"></i> <span class="sr-only">Share on Facebook</span> </a> </li> <li> <a href="https://twitter.com/intent/tweet?text=Code+without+automated+tests%3F+Are+we+serious%3F%20https%3A%2F%2Ftech-lessons.in%2Fcode-without-automated-tests%2F" target="_blank" title=""> <i class="fa fa-twitter-square fa-2x" aria-hidden="true"></i> <span class="sr-only">Tweet</span> </a> </li> <li> <a href="http://www.linkedin.com/shareArticle?mini=true&url=https://tech-lessons.in/code-without-automated-tests/&title=Code+without+automated+tests%3F+Are+we+serious%3F%20%7C%20tech-lessons.in&summary=&source=https://tech-lessons.in/code-without-automated-tests/" target="_blank" title=" LinkedIn"> <i class="fa fa-linkedin fa-2x" aria-hidden="true"></i> <span class="sr-only">Share on LinkedIn</span> </a> </li> </ul> </div> <!-- Tag list --> <footer> <div class="tag-list"> <div class="meta">Tags</div> <a class="button" href="/tags#Agile"> <p><i class="fa fa-tag fa-fw"></i> Agile</p> </a> <a class="button" href="/tags#Refactoring"> <p><i class="fa fa-tag fa-fw"></i> Refactoring</p> </a> <a class="button" href="/tags#Testing"> <p><i class="fa fa-tag fa-fw"></i> Testing</p> </a> </div> </footer> </article> <!-- Disqus --> <div class="comments"> <div id="disqus_thread"></div> <script type="text/javascript"> var disqus_shortname = 'techlessons'; (function() { var dsq = document.createElement('script'); dsq.type = 'text/javascript'; dsq.async = true; dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js'; (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq); })(); </script> <noscript>Please enable JavaScript to view comments.</noscript> </div> <!-- Post navigation --> <div id="post-nav"> <div id="next-post"> <a alt="Diving into Java Bytecode" href="/diving-into-java-bytecode/"> <p>Next post</p> Diving into Java Bytecode </a> </div> </div> <!-- To change color of links in the page --> <style> header#main { background-repeat:no-repeat; background-image: url('/assets/img/pexels/code-without-tests.png'); } </style> </div> <footer class="site-footer"> <p class="text"> tech-lessons.in © 2020. All Rights Reserved. Powered by <a href='https://jekyllrb.com/'>Jekyll</a> </p> <div class="footer-icons"> <ul> <li> <a href="https://github.com/sarthakmakhija" title="Follow on GitHub"> <span class="fa-stack fa-lg"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-github fa-stack-1x fa-inverse"></i> </span> </a> </li> <li> <a href="https://www.linkedin.com/in/sarthak-makhija-7a165a55/" title="Follow on LinkedIn"> <span class="fa-stack fa-lg"> <i class="fa fa-circle fa-stack-2x"></i> <i class="fa fa-linkedin fa-stack-1x fa-inverse"></i> </span> </a> </li> </ul> <ul> </ul> </div> </footer> </body> </html>
